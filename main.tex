\documentclass{uetgraduation}\RequirePackage{float}

% Gói bổ sung cho code listing
\RequirePackage{listings}
\RequirePackage{xcolor}

% Gói bổ sung cho biểu đồ (Chương 4)
\RequirePackage{pgfplots}
\pgfplotsset{compat=1.17}

% Cấu hình hiển thị code Arduino
\lstdefinestyle{arduino}{
    backgroundcolor=\color{white},
    commentstyle=\color{gray},
    keywordstyle=\color{blue}\bfseries,
    numberstyle=\tiny\color{gray},
    stringstyle=\color{orange},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    language=C++,
    morekeywords={setup, loop, pinMode, digitalWrite, digitalRead, analogRead, Serial, HIGH, LOW, INPUT, OUTPUT, INPUT_PULLUP, byte, boolean}
}

\begin{document}

%======================================================================
% THÔNG TIN TRANG BÌA
%======================================================================
\studentname{Nguyễn Vũ Quang}
\title{Xây dựng khung đế robot có khả năng cân bằng trọng tâm}
\documenttype{Khóa luận tốt nghiệp đại học hệ chính quy}
\major{Kỹ thuật điều khiển và tự động hóa}
\year{2025}
\supervisor{ThS. Đặng Anh Việt}
\makecovers

%======================================================================
% TÓM TẮT
%======================================================================
\begin{preamble}{TÓM TẮT}
\textbf{Tóm tắt:} Khóa luận trình bày quá trình nghiên cứu, thiết kế và chế tạo khung đế robot di động có khả năng tự động cân bằng trọng tâm. Hệ thống sử dụng cảm biến lực (Loadcell) kết hợp với module HX711 để đo chênh lệch trọng lượng giữa hai bên khung. Thuật toán điều khiển PID được áp dụng để điều khiển động cơ bước di chuyển khối đối trọng trên cơ cấu vitme, từ đó bù đắp sự mất cân bằng khi tải thay đổi.

Kết quả thực nghiệm cho thấy hệ thống có khả năng phát hiện và bù đắp độ lệch trọng tâm trong phạm vi $\pm$100g với thời gian đáp ứng nhanh. Chương trình điều khiển được viết theo kiến trúc Non-blocking, đảm bảo động cơ bước hoạt động mượt mà ở tốc độ cao mà không bị ảnh hưởng bởi các tác vụ đọc cảm biến hay giao tiếp Serial.

Khóa luận cũng đề xuất các hướng phát triển mở rộng như điều khiển vị trí, tốc độ chuyển dịch và tích hợp vào robot di động thực tế.

\textit{\textbf{Từ khóa:} Cân bằng trọng tâm, Loadcell, PID, Động cơ bước, Arduino, Non-blocking, Robot di động.}
\end{preamble}

%======================================================================
% LỜI CẢM ƠN
%======================================================================
\begin{preamble}{LỜI CẢM ƠN}
Để hoàn thành khóa luận tốt nghiệp này, tôi đã nhận được rất nhiều sự giúp đỡ và hỗ trợ từ thầy cô, gia đình và bạn bè.

Trước hết, tôi xin gửi lời cảm ơn chân thành và sâu sắc nhất đến ThS. Đặng Anh Việt -- người đã trực tiếp hướng dẫn, chỉ bảo tận tình và tạo mọi điều kiện thuận lợi cho tôi trong suốt quá trình thực hiện khóa luận.

Tôi xin chân thành cảm ơn các thầy cô giáo trong Khoa Cơ học kỹ thuật và Tự động hóa, Trường Đại học Công nghệ, Đại học Quốc gia Hà Nội đã trang bị cho tôi những kiến thức quý báu trong suốt thời gian học tập tại trường.

Cuối cùng, tôi xin gửi lời cảm ơn đến gia đình, bạn bè đã luôn động viên, khích lệ tôi trong suốt quá trình học tập và thực hiện khóa luận.

\vspace{2cm}
\hfill Hà Nội, tháng 6 năm 2025

\hfill \textbf{Sinh viên}

\vspace{1.5cm}
\hfill \textbf{Nguyễn Vũ Quang}
\end{preamble}

%======================================================================
% LỜI CAM ĐOAN
%======================================================================
\begin{preamble}{LỜI CAM ĐOAN}
Tôi xin cam đoan đây là công trình nghiên cứu của riêng tôi dưới sự hướng dẫn của ThS. Đặng Anh Việt. Các số liệu, kết quả nêu trong khóa luận là trung thực và chưa từng được ai công bố trong bất kỳ công trình nào khác.

Tôi xin cam đoan rằng mọi sự giúp đỡ cho việc thực hiện khóa luận này đã được cảm ơn và các thông tin trích dẫn trong khóa luận đã được chỉ rõ nguồn gốc.

\vspace{2cm}
\hfill Hà Nội, ngày \hspace{1cm} tháng \hspace{1cm} năm 2025

\hfill \textbf{Sinh viên thực hiện}

\vspace{1.5cm}
\hfill \textbf{Nguyễn Vũ Quang}
\end{preamble}

%======================================================================
% MỤC LỤC VÀ DANH SÁCH
%======================================================================
\begin{contentlisting}

\tableofcontents
\listoffigures
\listoftables

\begin{contentlistingsection}{Danh sách các từ viết tắt}
\textbf{PID:} Proportional-Integral-Derivative -- Bộ điều khiển vi tích phân tỷ lệ.

\textbf{PWM:} Pulse Width Modulation -- Điều chế độ rộng xung.

\textbf{ADC:} Analog to Digital Converter -- Bộ chuyển đổi tương tự sang số.

\textbf{I2C:} Inter-Integrated Circuit -- Giao thức truyền thông nối tiếp.

\textbf{SPI:} Serial Peripheral Interface -- Giao diện ngoại vi nối tiếp.

\textbf{UART:} Universal Asynchronous Receiver-Transmitter -- Bộ thu phát không đồng bộ.

\textbf{GPIO:} General Purpose Input/Output -- Chân vào/ra đa mục đích.

\textbf{RPM:} Revolutions Per Minute -- Vòng quay trên phút.

\textbf{ISR:} Interrupt Service Routine -- Trình phục vụ ngắt.
\end{contentlistingsection}

\end{contentlisting}

\begin{preamble}{MỞ ĐẦU}
Trong bối cảnh cuộc Cách mạng Công nghiệp 4.0, robot di động và các xe tự hành đang ngày càng đóng vai trò quan trọng trong các lĩnh vực từ logistics, vận chuyển hàng hóa trong nhà máy đến các ứng dụng quân sự và y tế. Một trong những thách thức kỹ thuật lớn nhất đối với các hệ thống này là khả năng duy trì sự ổn định khi vận hành, đặc biệt là khi phải mang vác các tải trọng có khối lượng và kích thước thay đổi liên tục, hoặc khi di chuyển trên các địa hình không bằng phẳng.

Việc trọng tâm của robot bị lệch khỏi trục đối xứng do phân bố tải trọng không đều sẽ dẫn đến nhiều hệ quả nghiêm trọng: gây mòn cơ khí không đều, làm giảm hiệu suất của động cơ truyền động, gây trượt bánh xe, sai lệch quỹ đạo di chuyển và trong trường hợp xấu nhất là gây lật robot, hư hỏng hàng hóa.

Tuy nhiên, các giải pháp cân bằng truyền thống hiện nay chủ yếu dựa vào thiết kế cơ khí tĩnh (như mở rộng chân đế, hạ thấp trọng tâm cố định) hoặc sử dụng hệ thống treo thụ động. Các phương pháp này bộc lộ nhược điểm lớn là thiếu tính linh hoạt, không thể thích nghi khi robot phải vận chuyển các loại hàng hóa có khối lượng và kích thước đa dạng. Do đó, việc nghiên cứu và phát triển hệ thống "Cân bằng chủ động" với khả năng tự động thu thập dữ liệu độ lệch và điều khiển cơ cấu chấp hành để tái lập trạng thái cân bằng trong thời gian thực là một yêu cầu cấp thiết, mang tính quyết định đến độ an toàn và hiệu quả vận hành của robot.

Xuất phát từ nhu cầu thực tiễn và tính ứng dụng cao của vấn đề, đề tài \textit{``Xây dựng khung đế robot có khả năng cân bằng trọng tâm''} được lựa chọn làm khóa luận tốt nghiệp. Đề tài hướng đến việc nghiên cứu, thiết kế và chế tạo một khung đế có khả năng tự động phát hiện và bù đắp độ lệch trọng tâm, tạo nền tảng cho việc phát triển các robot di động ổn định hơn trong tương lai.
\end{preamble}

%======================================================================
% CHƯƠNG 1: TỔNG QUAN
%======================================================================
\chapter{Tổng quan}

\section{Đặt vấn đề và lý do chọn đề tài}

Trong những năm gần đây, robot di động (Mobile Robot) đã trở thành một trong những lĩnh vực nghiên cứu và ứng dụng phát triển mạnh mẽ nhất trong ngành tự động hóa. Từ các robot vận chuyển hàng hóa trong nhà máy, robot phục vụ trong nhà hàng, đến các robot thám hiểm địa hình phức tạp -- tất cả đều đòi hỏi khả năng di chuyển ổn định và thích ứng với các điều kiện tải trọng thay đổi.

Một thách thức kỹ thuật quan trọng trong thiết kế robot di động là vấn đề \textbf{cân bằng trọng tâm}. Khi robot mang theo tải trọng hoặc được trang bị cánh tay thao tác (manipulator), trọng tâm của hệ thống sẽ thay đổi theo vị trí và khối lượng của tải. Sự dịch chuyển trọng tâm này gây ra nhiều hệ quả tiêu cực:

\begin{itemize}
    \item \textbf{Giảm ổn định động học:} Robot dễ bị lật hoặc mất cân bằng khi di chuyển trên địa hình không bằng phẳng, đặc biệt khi tải lệch về một phía.
    \item \textbf{Tăng tải không đều lên các bánh xe:} Dẫn đến mài mòn không đồng đều, giảm tuổi thọ cơ cấu truyền động và ảnh hưởng đến độ chính xác điều khiển quỹ đạo.
    \item \textbf{Tăng tiêu hao năng lượng:} Các động cơ dẫn động phải bù đắp momen do tải lệch gây ra, làm giảm hiệu suất và thời gian hoạt động của robot.
    \item \textbf{Ảnh hưởng đến độ chính xác thao tác:} Với robot có cánh tay, sự mất cân bằng của đế ảnh hưởng trực tiếp đến độ chính xác định vị của end-effector.
\end{itemize}

Giải pháp truyền thống cho vấn đề này thường là thiết kế đế robot với trọng tâm thấp và phân bố tải đối xứng. Tuy nhiên, cách tiếp cận này không linh hoạt khi tải trọng thay đổi trong quá trình vận hành. Một giải pháp tiên tiến hơn là sử dụng \textbf{hệ thống cân bằng trọng tâm chủ động} (Active Center of Gravity Balancing System), trong đó một cơ cấu chấp hành sẽ tự động di chuyển khối đối trọng để bù đắp sự thay đổi trọng tâm.

Hệ thống cân bằng trọng tâm chủ động đòi hỏi sự kết hợp của nhiều thành phần: cảm biến đo lường độ lệch, cơ cấu chấp hành di chuyển đối trọng, và thuật toán điều khiển để xác định vị trí đối trọng tối ưu. Đây là một bài toán điều khiển vòng kín điển hình, phù hợp để áp dụng các kiến thức về \textbf{lý thuyết điều khiển tự động}, \textbf{cảm biến và đo lường}, cũng như \textbf{hệ thống nhúng thời gian thực}.

\section{Mục tiêu nghiên cứu}

Mục tiêu tổng quát của khóa luận là thiết kế và chế tạo một khung đế robot di động có khả năng tự động cân bằng trọng tâm khi tải trọng thay đổi. Để đạt được mục tiêu này, các mục tiêu cụ thể được xác định như sau:

\subsection{Mục tiêu về nghiên cứu lý thuyết}

Nghiên cứu nguyên lý cân bằng trọng tâm dựa trên lý thuyết momen lực và điều kiện cân bằng tĩnh. Tìm hiểu các phương pháp đo lường độ lệch trọng tâm, trong đó tập trung vào việc sử dụng cảm biến lực (Loadcell) để xác định sự chênh lệch tải trọng giữa các điểm tựa.

Nghiên cứu thuật toán điều khiển PID (Proportional-Integral-Derivative) và phương pháp tinh chỉnh tham số phù hợp với đặc tính của hệ thống cơ điện tử. Đặc biệt, nghiên cứu các kỹ thuật xử lý vùng chết (Deadzone), độ trễ (Hysteresis) để tránh hiện tượng dao động quanh điểm cân bằng.

Nghiên cứu kiến trúc lập trình thời gian thực cho hệ thống nhúng, đảm bảo khả năng đáp ứng nhanh và ổn định của hệ thống điều khiển.

\subsection{Mục tiêu về thiết kế và chế tạo}

Thiết kế khung cơ khí có kích thước phù hợp với robot di động cỡ nhỏ và vừa (khoảng 35$\times$35cm), đảm bảo độ cứng vững và khả năng tích hợp các thành phần điện tử.

Thiết kế cơ cấu di chuyển đối trọng sử dụng động cơ bước kết hợp truyền động vitme, đảm bảo độ chính xác vị trí và khả năng chịu tải.

Thiết kế mạch điện tử điều khiển bao gồm: mạch đọc tín hiệu từ cảm biến lực, mạch điều khiển động cơ bước, và giao tiếp với vi điều khiển.

Chế tạo và lắp ráp hoàn chỉnh mô hình khung đế cân bằng.

\subsection{Mục tiêu về phần mềm điều khiển}

Xây dựng chương trình điều khiển trên nền tảng vi điều khiển Arduino, tích hợp thuật toán PID để tự động điều chỉnh vị trí đối trọng.

Đảm bảo chương trình hoạt động theo kiến trúc Non-blocking (không chặn), cho phép động cơ bước vận hành mượt mà ở tốc độ cao mà không bị ảnh hưởng bởi các tác vụ đọc cảm biến hay giao tiếp.

Phát triển giao diện giám sát thông qua Serial Monitor để theo dõi các thông số hoạt động và hỗ trợ quá trình tinh chỉnh hệ thống.

\subsection{Mục tiêu về thử nghiệm và đánh giá}

Tiến hành thử nghiệm hệ thống với các kịch bản tải trọng khác nhau. Đánh giá các chỉ tiêu: thời gian đáp ứng, độ chính xác cân bằng, độ ổn định, và phạm vi tải trọng có thể bù đắp.

So sánh kết quả thực nghiệm với mục tiêu thiết kế, phân tích các hạn chế và đề xuất hướng cải tiến.

\section{Đối tượng và phạm vi nghiên cứu}

\subsection{Đối tượng nghiên cứu}

Đối tượng nghiên cứu của khóa luận bao gồm các thành phần chính của hệ thống cân bằng trọng tâm:

\textbf{Cảm biến lực Loadcell và module HX711:} Loadcell là cảm biến đo lực dựa trên nguyên lý điện trở biến dạng. Module HX711 là bộ chuyển đổi ADC 24-bit chuyên dụng cho loadcell, có khả năng đọc tín hiệu với độ phân giải cao. Trong dự án này, thư viện HX711\_ADC được sử dụng với ưu điểm hỗ trợ chế độ đọc Non-blocking, cho phép vi điều khiển thực hiện các tác vụ khác trong khi chờ dữ liệu từ cảm biến.

\textbf{Động cơ bước và driver TB6600:} Động cơ bước Nema 17 được sử dụng làm cơ cấu chấp hành, với đặc điểm điều khiển vị trí chính xác theo vòng hở. Driver TB6600 hỗ trợ điều khiển vi bước (microstepping) với các mức 1/2, 1/4, 1/8, 1/16, cho phép tăng độ phân giải và giảm rung động.

\textbf{Vi điều khiển Arduino:} Nền tảng Arduino (chip ATmega328P, tần số 16MHz) được chọn làm bộ xử lý trung tâm do tính phổ biến, dễ lập trình, và có nhiều thư viện hỗ trợ. Thư viện AccelStepper được sử dụng để điều khiển động cơ bước với khả năng điều chỉnh tốc độ và gia tốc mượt mà.

\textbf{Thuật toán điều khiển PID:} Bộ điều khiển PID là thuật toán điều khiển vòng kín phổ biến trong công nghiệp, phù hợp cho các hệ thống yêu cầu độ chính xác và ổn định cao. Thư viện PID\_v1 cho Arduino được sử dụng để triển khai thuật toán.

\textbf{Kỹ thuật lập trình thời gian thực:} Nghiên cứu các vấn đề về độ trễ (latency), blocking I/O, và các giải pháp Non-blocking để đảm bảo hệ thống đáp ứng các ràng buộc thời gian thực.

\subsection{Phạm vi nghiên cứu}

Khóa luận tập trung vào các giới hạn sau:

\textbf{Về không gian:} Hệ thống cân bằng trọng tâm theo \textbf{một trục} (trái-phải). Việc mở rộng sang hai trục được đề cập như hướng phát triển.

\textbf{Về kích thước:} Khung đế có kích thước 35$\times$35cm, phù hợp với các robot di động cỡ nhỏ và vừa. Hành trình di chuyển đối trọng: 120mm về bên trái, 110mm về bên phải (tính từ vị trí tâm).

\textbf{Về tải trọng:} Cảm biến loadcell có tải trọng định mức 50kg mỗi cụm. Khối lượng đối trọng được tính toán dựa trên nguyên lý momen lực với hệ số 0.69, cho phép cân bằng độ lệch lên đến 600g (với đối trọng khoảng 870g).

\textbf{Về điều khiển:} Sử dụng điều khiển vòng hở cho động cơ bước (không có encoder phản hồi vị trí). Thuật toán PID với vùng chết $\pm$100g -- tức là hệ thống chấp nhận độ lệch trong phạm vi này mà không cần điều chỉnh.

\textbf{Về hiệu năng:} Tốc độ tối đa của động cơ bước bị giới hạn bởi khả năng xử lý của vi điều khiển và đặc tính của thư viện AccelStepper (khoảng 15000 bước/giây trong điều kiện tối ưu).

\section{Phương pháp nghiên cứu}

Khóa luận sử dụng kết hợp các phương pháp nghiên cứu sau:

\subsection{Phương pháp nghiên cứu lý thuyết}

Tham khảo các tài liệu về cơ học (momen lực, điều kiện cân bằng) [7], lý thuyết điều khiển PID [7], nguyên lý cảm biến loadcell [5], và lập trình hệ thống nhúng [6].

Tổng hợp kiến thức từ các nghiên cứu trước đó về điều khiển động cơ bước, đặc biệt là các vấn đề về hiệu năng thời gian thực khi kết hợp nhiều tác vụ (đọc cảm biến, điều khiển động cơ, giao tiếp Serial).

\subsection{Phương pháp mô hình hóa và thiết kế}

Xây dựng mô hình toán học của hệ thống cân bằng dựa trên nguyên lý momen lực. Từ đó xác định mối quan hệ giữa độ lệch tải trọng và vị trí đối trọng cần thiết để cân bằng.

Thiết kế cơ khí sử dụng phương pháp thiết kế mô-đun, cho phép dễ dàng điều chỉnh và thay thế các thành phần. Thiết kế mạch điện theo sơ đồ khối, xác định rõ chức năng và giao tiếp của từng module.

Thiết kế phần mềm theo kiến trúc phân tầng: tầng phần cứng (Hardware Abstraction Layer), tầng điều khiển (Control Layer), và tầng ứng dụng (Application Layer).

\subsection{Phương pháp thực nghiệm}

Chế tạo mô hình thực tế dựa trên thiết kế đã xây dựng. Tiến hành hiệu chuẩn (calibration) các cảm biến loadcell để đảm bảo độ chính xác đo lường.

Thực hiện các bài test với nhiều kịch bản tải trọng khác nhau: tải tĩnh (đặt vật nặng cố định), tải động (di chuyển vật nặng trong quá trình hoạt động), và tải biến thiên (thay đổi khối lượng tải).

Thu thập dữ liệu thông qua Serial Monitor, bao gồm: giá trị đọc từ loadcell, sai số (Input), tín hiệu điều khiển (Output), và tốc độ động cơ. Phân tích dữ liệu để đánh giá hiệu quả của thuật toán điều khiển.

\subsection{Phương pháp phân tích và đánh giá}

So sánh kết quả thực nghiệm với các chỉ tiêu thiết kế ban đầu. Phân tích nguyên nhân của các sai lệch (nếu có) và đề xuất giải pháp khắc phục.

Đánh giá định lượng các thông số: thời gian đáp ứng (từ khi có tải lệch đến khi đạt cân bằng), độ chính xác cân bằng (sai số còn lại sau khi ổn định), và phạm vi hoạt động (độ lệch tối đa có thể bù đắp).

Phân tích các yếu tố ảnh hưởng đến hiệu năng hệ thống, bao gồm: tham số PID, tốc độ lấy mẫu, độ phân giải microstep, và các vấn đề về lập trình thời gian thực.

\section{Ý nghĩa khoa học và thực tiễn}

\subsection{Ý nghĩa khoa học}

Khóa luận đóng góp vào việc nghiên cứu ứng dụng lý thuyết điều khiển tự động trong bài toán cân bằng trọng tâm cho robot di động. Các kết quả nghiên cứu về ảnh hưởng của kiến trúc phần mềm (blocking vs non-blocking) đến hiệu năng điều khiển động cơ bước có giá trị tham khảo cho các nghiên cứu liên quan.

Việc phân tích chi tiết các vấn đề thời gian thực trong hệ thống nhúng -- từ độ trễ của giao tiếp Serial đến ảnh hưởng của tần số lấy mẫu -- cung cấp cơ sở lý thuyết và thực nghiệm cho việc thiết kế các hệ thống điều khiển tương tự.

\subsection{Ý nghĩa thực tiễn}

Sản phẩm của khóa luận là một khung đế robot có khả năng tự cân bằng, có thể được tích hợp vào các robot di động thực tế để cải thiện độ ổn định khi vận hành.

Các kinh nghiệm thiết kế và chế tạo (lựa chọn linh kiện, giải quyết các vấn đề kỹ thuật, tinh chỉnh hệ thống) được tài liệu hóa trong khóa luận, có thể làm tài liệu tham khảo cho các dự án tương tự.

Mã nguồn chương trình điều khiển được cung cấp đầy đủ trong phụ lục, có thể được sử dụng lại hoặc phát triển thêm cho các ứng dụng khác.

\section{Bố cục khóa luận}

Khóa luận được trình bày trong 5 chương với nội dung như sau:

\textbf{Chương 1: Tổng quan} -- Trình bày bối cảnh và lý do chọn đề tài, xác định mục tiêu nghiên cứu, đối tượng và phạm vi nghiên cứu, các phương pháp nghiên cứu được sử dụng, cũng như ý nghĩa khoa học và thực tiễn của đề tài.

\textbf{Chương 2: Cơ sở lý thuyết} -- Trình bày các kiến thức nền tảng về nguyên lý cân bằng trọng tâm và momen lực, cảm biến lực Loadcell và module HX711, động cơ bước và kỹ thuật vi bước, vi điều khiển Arduino, thuật toán điều khiển PID, và các vấn đề lập trình thời gian thực cho hệ thống nhúng.

\textbf{Chương 3: Thiết kế hệ thống} -- Mô tả chi tiết quá trình thiết kế gồm: phân tích yêu cầu, thiết kế cơ khí (khung, cơ cấu vitme-thanh trượt, bố trí loadcell), thiết kế mạch điện (sơ đồ khối, kết nối phần cứng), và thiết kế phần mềm (cấu trúc chương trình, quy trình Homing, logic điều khiển PID với Deadzone và Hysteresis).

\textbf{Chương 4: Thực nghiệm và đánh giá} -- Trình bày môi trường và điều kiện thử nghiệm, quá trình tinh chỉnh tham số PID, kết quả thực nghiệm với các kịch bản tải trọng khác nhau, phân tích hiệu năng hệ thống, và đánh giá so với mục tiêu đề ra.

\textbf{Chương 5: Kết luận và hướng phát triển} -- Tổng kết các kết quả đạt được của khóa luận, nêu rõ các hạn chế còn tồn tại, và đề xuất các hướng phát triển tiếp theo bao gồm: tăng tốc độ phản hồi, mở rộng cân bằng hai trục, và tích hợp điều khiển vị trí/tốc độ.

%======================================================================
% CHƯƠNG 2: CƠ SỞ LÝ THUYẾT
%======================================================================
\chapter{Cơ sở lý thuyết}

Chương này trình bày các kiến thức nền tảng cần thiết cho việc thiết kế và xây dựng hệ thống cân bằng trọng tâm tự động. Các nội dung được trình bày bao gồm: lý thuyết cơ học về cân bằng và momen lực, nguyên lý hoạt động của cảm biến lực và module chuyển đổi tín hiệu, đặc tính của động cơ bước và kỹ thuật điều khiển vi bước, nền tảng vi điều khiển Arduino, thuật toán điều khiển PID, và đặc biệt là các vấn đề về lập trình thời gian thực trong hệ thống nhúng.

%======================================================================
% PHẦN BỔ SUNG CHO CHƯƠNG 2: SO SÁNH CÁC PHƯƠNG PHÁP CÂN BẰNG
% Chèn vào đầu Chương 2, sau phần giới thiệu chương
% hoặc sau phần "Nguyên lý cân bằng trọng tâm"
%======================================================================

\section{So sánh các phương pháp cân bằng robot}

Trong lĩnh vực robot di động, có nhiều phương pháp khác nhau để duy trì sự cân bằng và ổn định. Mỗi phương pháp có nguyên lý hoạt động, ưu điểm và hạn chế riêng, phù hợp với các ứng dụng cụ thể. Phần này trình bày và so sánh bốn phương pháp cân bằng phổ biến nhất.

\subsection{Các phương pháp cân bằng chính}

\textbf{Phương pháp 1 - Điều khiển bánh xe (Wheel-based Balancing):} Phương pháp này được sử dụng trong các sản phẩm thương mại như Segway và nhiều robot giao hàng [9]. Robot di chuyển bánh xe theo hướng nghiêng để giữ trọng tâm nằm trên đa giác đỡ.

\textbf{Phương pháp 2 - Bánh đà/Con quay hồi chuyển (Reaction Wheel/CMG):} Bánh đà quay tốc độ cao tạo momen phản lực khi thay đổi tốc độ, được ứng dụng trong điều khiển tư thế vệ tinh và một số robot thí nghiệm [10]. Khi cần tạo momen cân bằng, động cơ tăng hoặc giảm tốc độ bánh đà, theo định luật bảo toàn momen động lượng, một momen phản lực sẽ tác động lên thân robot. Control Moment Gyroscope (CMG) là biến thể sử dụng hiệu ứng tiến động của con quay hồi chuyển.

\textbf{Phương pháp 3 - Khối lượng di động (Moving Mass):} Nguyên lý hoạt động dựa trên việc di chuyển một khối lượng đối trọng để thay đổi vị trí trọng tâm của hệ thống. Khi phát hiện độ lệch, khối đối trọng được di chuyển về phía đối diện để bù đắp momen lực gây mất cân bằng. Đây chính là phương pháp được áp dụng trong đề tài này.

\textbf{Phương pháp 4 - Mở rộng đa giác đỡ (Support Polygon Expansion):} Phương pháp này tăng độ ổn định tĩnh bằng cách mở rộng diện tích tiếp xúc với mặt đất. Các robot có thể sử dụng chân chống, bánh xe phụ, hoặc thay đổi tư thế để mở rộng đa giác đỡ. Tuy nhiên, phương pháp này làm giảm tính linh hoạt của robot.

\subsection{Bảng so sánh tổng hợp}

Bảng 2.1 trình bày so sánh chi tiết bốn phương pháp cân bằng theo các tiêu chí quan trọng.

\begin{table}[H]{So sánh các phương pháp cân bằng robot}
\centering
\small
\begin{tabular}{|p{2.8cm}|p{2.8cm}|p{2.8cm}|p{2.8cm}|p{2.8cm}|}
\hline
\textbf{Tiêu chí} & \textbf{Điều khiển bánh xe} & \textbf{Bánh đà/CMG} & \textbf{Khối lượng di động} & \textbf{Mở rộng đa giác đỡ} \\
\hline
\textbf{Nguyên lý} & Di chuyển bánh xe theo hướng nghiêng & Thay đổi tốc độ bánh đà tạo momen phản lực & Di chuyển đối trọng thay đổi trọng tâm & Tăng diện tích tiếp xúc mặt đất \\
\hline
\textbf{Cảm biến chính} & IMU (gyro + accel) & IMU (gyro + accel) & Loadcell hoặc IMU & Cảm biến tiếp xúc, IMU \\
\hline
\textbf{Cơ cấu chấp hành} & Động cơ DC/BLDC cho bánh xe & Động cơ BLDC tốc độ cao & Động cơ bước + vitme/đai & Động cơ servo, xi-lanh \\
\hline
\textbf{Thời gian đáp ứng} & Rất nhanh (ms) & Nhanh (ms) & Trung bình (100ms-1s) & Chậm (giây) \\
\hline
\textbf{Khả năng cân bằng tĩnh} & Không (cần di chuyển liên tục) & Có (giới hạn bởi saturation) & Có (trong phạm vi hành trình) & Có (ổn định nhất) \\
\hline
\textbf{Tiêu hao năng lượng} & Cao khi đứng yên & Cao (bánh đà quay liên tục) & Thấp khi đã cân bằng & Rất thấp \\
\hline
\textbf{Độ phức tạp điều khiển} & Cao (hệ bất ổn định) & Rất cao & Trung bình & Thấp \\
\hline
\textbf{Độ phức tạp cơ khí} & Thấp-Trung bình & Cao & Trung bình & Thấp-Cao \\
\hline
\textbf{Khả năng chịu tải thay đổi} & Hạn chế & Hạn chế & Tốt (thiết kế phù hợp) & Tốt \\
\hline
\textbf{Tính linh hoạt di chuyển} & Cao & Cao & Cao & Thấp \\
\hline
\textbf{Ứng dụng tiêu biểu} & Segway, robot giao hàng & Vệ tinh, xe đạp tự lái & Robot mang tải, cần cẩu & Robot công nghiệp, xe nâng \\
\hline
\textbf{Chi phí triển khai} & Trung bình & Cao & Thấp-Trung bình & Thấp \\
\hline
\end{tabular}
\end{table}

\subsection{Phân tích ưu nhược điểm chi tiết}

\textbf{Điều khiển bánh xe:}
Ưu điểm bao gồm khả năng đáp ứng rất nhanh, cấu trúc cơ khí đơn giản, và robot có thể di chuyển linh hoạt. Nhược điểm chính là không thể cân bằng tĩnh (phải di chuyển liên tục để giữ thăng bằng), tiêu hao năng lượng cao khi đứng yên, và yêu cầu mặt sàn phẳng để hoạt động hiệu quả. Phương pháp này phù hợp với các ứng dụng di chuyển liên tục như robot giao hàng, xe cân bằng cá nhân.

\textbf{Bánh đà/CMG:}
Ưu điểm là có thể cân bằng mà không cần di chuyển bánh xe, đáp ứng nhanh, và hoạt động được trên nhiều loại địa hình. Nhược điểm bao gồm tiêu hao năng lượng liên tục (bánh đà phải quay), vấn đề bão hòa momen động lượng (saturation) khi nhiễu kéo dài, độ phức tạp cơ khí cao, và tiếng ồn từ bánh đà tốc độ cao. Phương pháp này phù hợp với vệ tinh, tàu vũ trụ, và các robot cần cân bằng chính xác trong thời gian ngắn.

\textbf{Khối lượng di động (Phương pháp được chọn):}
Ưu điểm là tiêu hao năng lượng thấp sau khi đã cân bằng (động cơ dừng), cấu trúc đơn giản với linh kiện phổ biến, có thể đo trực tiếp phân bố tải bằng loadcell, và phù hợp với ứng dụng cân bằng tĩnh hoặc bán tĩnh. Nhược điểm bao gồm thời gian đáp ứng chậm hơn (phụ thuộc vào tốc độ vitme), giới hạn bởi hành trình di chuyển của đối trọng, và khả năng bù đắp phụ thuộc vào khối lượng đối trọng. Phương pháp này phù hợp với robot mang tải có trọng tâm thay đổi chậm, khung đế cân bằng cho cánh tay robot.

\textbf{Mở rộng đa giác đỡ:}
Ưu điểm là độ ổn định cao nhất, không cần điều khiển phức tạp, và tiêu hao năng lượng rất thấp. Nhược điểm là làm giảm tính linh hoạt và khả năng di chuyển, tăng kích thước và khối lượng robot, và thời gian chuyển đổi trạng thái chậm. Phương pháp này phù hợp với robot công nghiệp cố định, xe nâng hàng, và các ứng dụng ưu tiên độ ổn định tuyệt đối.

\subsection{Lý do lựa chọn phương pháp khối lượng di động}

Đề tài này lựa chọn phương pháp khối lượng di động dựa trên các lý do sau:

Thứ nhất, về đặc điểm ứng dụng: Khung đế robot được thiết kế để cân bằng khi tải thay đổi (ví dụ: cánh tay robot gắp vật), không yêu cầu thời gian đáp ứng cực nhanh như robot tự cân bằng động.

Thứ hai, về hiệu quả năng lượng: Sau khi đạt vị trí cân bằng, động cơ bước có thể dừng hoàn toàn (giữ vị trí bằng momen từ tính), tiết kiệm năng lượng đáng kể so với phương pháp bánh đà.

Thứ ba, về khả năng đo lường: Việc sử dụng loadcell cho phép đo trực tiếp chênh lệch trọng lượng giữa hai bên, cung cấp phản hồi chính xác về trạng thái cân bằng mà không cần tính toán phức tạp từ góc nghiêng.

Thứ tư, về tính khả thi: Các linh kiện cần thiết (động cơ bước, vitme, loadcell, Arduino) đều phổ biến và có giá thành hợp lý tại Việt Nam, phù hợp với điều kiện nghiên cứu và triển khai.

Thứ năm, về độ phức tạp: So với phương pháp bánh đà hoặc CMG, phương pháp khối lượng di động có độ phức tạp cơ khí và điều khiển thấp hơn, thuận lợi cho việc nghiên cứu và phát triển trong khuôn khổ đồ án tốt nghiệp.

\section{Lý thuyết cân bằng trọng tâm và momen lực}

\subsection{Khái niệm trọng tâm}

Trọng tâm (Center of Gravity - CoG) là điểm đặt của hợp lực trọng trường tác dụng lên vật thể [8]. Đối với một hệ thống gồm $n$ vật thể rời rạc, vị trí trọng tâm theo trục $x$ được xác định bởi công thức:

\begin{equation}
x_G = \frac{\sum_{i=1}^{n} m_i \cdot x_i}{\sum_{i=1}^{n} m_i} = \frac{\sum_{i=1}^{n} m_i \cdot x_i}{M}
\label{eq:center_of_gravity}
\end{equation}

trong đó $x_G$ là tọa độ trọng tâm của hệ, $m_i$ là khối lượng của vật thể thứ $i$, $x_i$ là tọa độ của vật thể thứ $i$ theo trục $x$, và $M = \sum m_i$ là tổng khối lượng của hệ.

Công thức tương tự được áp dụng cho các trục $y$ và $z$ trong không gian ba chiều. Trong phạm vi khóa luận này, bài toán được đơn giản hóa thành cân bằng theo một trục (trái-phải), tương ứng với việc xét trọng tâm trên trục $x$.

\subsection{Momen lực và điều kiện cân bằng tĩnh}

Momen lực (Torque) là đại lượng vật lý đặc trưng cho tác dụng làm quay của một lực đối với một trục quay. Độ lớn của momen lực được tính theo công thức:

\begin{equation}
M = F \times d
\label{eq:torque}
\end{equation}

trong đó $M$ là momen lực (đơn vị N.m hoặc N.mm), $F$ là lực tác dụng (N), và $d$ là cánh tay đòn -- khoảng cách vuông góc từ đường tác dụng của lực đến trục quay (m hoặc mm).

Quy ước dấu: Momen làm vật quay theo chiều kim đồng hồ thường được quy ước là âm, ngược chiều kim đồng hồ là dương (hoặc ngược lại, tùy theo hệ quy chiếu được chọn).

Điều kiện cân bằng tĩnh của một vật rắn yêu cầu tổng các momen lực tác dụng lên vật đối với một trục quay bất kỳ phải bằng không:

\begin{equation}
\sum M = 0
\label{eq:equilibrium}
\end{equation}

Điều kiện này có nghĩa là tổng các momen theo chiều dương phải cân bằng với tổng các momen theo chiều âm.

\subsection{Áp dụng nguyên lý momen vào bài toán cân bằng khung robot}

Xét mô hình khung đế robot như một thanh cứng được đỡ tại điểm tựa ở giữa (tâm khung). Khi có tải trọng đặt lệch về một phía, momen do tải gây ra sẽ làm khung mất cân bằng. Để khôi phục cân bằng, cần di chuyển một khối đối trọng về phía đối diện sao cho momen do đối trọng tạo ra bù đắp momen do tải.

Điều kiện cân bằng được viết như sau:

\begin{equation}
m_{slider} \times d_{slider} = m_{load} \times d_{load}
\label{eq:balance_condition}
\end{equation}

trong đó $m_{slider}$ là khối lượng của khối đối trọng (kg hoặc g), $d_{slider}$ là khoảng cách từ đối trọng đến tâm khung (mm), $m_{load}$ là độ chênh lệch khối lượng tải giữa hai bên (kg hoặc g), và $d_{load}$ là khoảng cách từ điểm đặt tải đến tâm khung (mm).

Từ phương trình \eqref{eq:balance_condition}, có thể suy ra vị trí cần thiết của đối trọng:

\begin{equation}
d_{slider} = \frac{m_{load} \times d_{load}}{m_{slider}}
\label{eq:slider_position}
\end{equation}

Phương trình này cho thấy một hạn chế quan trọng: với khối lượng đối trọng cố định $m_{slider}$ và hành trình giới hạn $d_{slider,max}$, độ lệch tải tối đa có thể bù đắp là:

\begin{equation}
m_{load,max} = \frac{m_{slider} \times d_{slider,max}}{d_{load}}
\label{eq:max_load}
\end{equation}

Với hệ thống được thiết kế có $d_{slider,max} = 120$mm và $d_{load} = 175$mm (một nửa chiều rộng khung 35cm), ta có công thức tổng quát:

\begin{equation}
m_{load,max} = \frac{120}{175} \times m_{slider} \approx 0.69 \times m_{slider}
\label{eq:max_load_general}
\end{equation}

Công thức này cho phép tra cứu nhanh khả năng cân bằng theo khối lượng đối trọng:

\begin{table}[H]
\centering
\caption{Khả năng cân bằng theo khối lượng đối trọng}
\begin{tabular}{|c|c|l|}
\hline
\textbf{Đối trọng} & \textbf{Độ lệch tối đa bù được} & \textbf{Ghi chú} \\
\hline
200g & $\sim$137g & Dùng trong thử nghiệm \\
\hline
300g & $\sim$206g & - \\
\hline
500g & $\sim$343g & Khuyên nghị ứng dụng nhẹ \\
\hline
1000g & $\sim$686g & Khuyên nghị ứng dụng nặng \\
\hline
1500g & $\sim$1029g & Sử dụng pin/acquy \\
\hline
\end{tabular}
\label{tab:balance_capacity}
\end{table}

Ví dụ cụ thể: với đối trọng $m_{slider} = 200$g, độ lệch tải tối đa có thể bù đắp là:

\begin{equation}
m_{load,max} = 0.69 \times 200 \approx 137 \text{ g}
\end{equation}

Kết quả này cho thấy để tăng khả năng cân bằng, có thể: (1) tăng khối lượng đối trọng, (2) tăng hành trình di chuyển, hoặc (3) bố trí tải gần tâm hơn.

\section{Cảm biến lực Loadcell và module HX711}

\subsection{Cấu tạo và nguyên lý hoạt động của Loadcell}

Loadcell là cảm biến chuyển đổi lực cơ học thành tín hiệu điện, hoạt động dựa trên hiệu ứng điện trở biến dạng (Piezoresistive effect)[5]. Cấu tạo cơ bản của loadcell gồm:

\textbf{Thân đàn hồi (Elastic element):} Thường làm từ thép hợp kim hoặc nhôm, được gia công với hình dạng đặc biệt để biến dạng theo hướng xác định khi chịu lực.

\textbf{Điện trở biến dạng (Strain gauge):} Là các dải điện trở mỏng được dán trực tiếp lên bề mặt thân đàn hồi. Khi thân đàn hồi biến dạng, điện trở của strain gauge thay đổi theo quan hệ:

\begin{equation}
\frac{\Delta R}{R} = GF \times \varepsilon
\label{eq:strain_gauge}
\end{equation}

trong đó $\Delta R/R$ là tỷ lệ thay đổi điện trở, $GF$ là hệ số gauge (Gauge Factor, thường từ 2 đến 4 cho strain gauge kim loại), và $\varepsilon$ là biến dạng tương đối của vật liệu.

\textbf{Cầu Wheatstone:} Bốn strain gauge được mắc theo cấu hình cầu Wheatstone để chuyển đổi sự thay đổi điện trở thành sự thay đổi điện áp. Cấu hình cầu đầy đủ (Full-bridge) cho độ nhạy cao nhất và khả năng bù nhiệt tốt.

Điện áp đầu ra của cầu Wheatstone:

\begin{equation}
V_{out} = V_{exc} \times \frac{\Delta R}{R}
\label{eq:wheatstone}
\end{equation}

trong đó $V_{exc}$ là điện áp kích thích (thường 5V hoặc 10V).

\subsection{Loadcell 3 dây và cách ghép thành cầu đầy đủ}

Trong dự án này, loadcell 3 dây (half-bridge) được sử dụng. Loại loadcell này chỉ chứa hai strain gauge, cần ghép hai loadcell lại để tạo thành cầu Wheatstone đầy đủ.

Cách đấu nối hai loadcell 3 dây thành một cầu cho module HX711:
\begin{itemize}
    \item Loadcell 1: Dây trắng vào E-, dây đen vào E+
    \item Loadcell 2: Dây trắng vào A-, dây đen vào E+
    \item Kết nối chung: Nối hai dây đỏ của cả hai loadcell lại với nhau và đưa vào chân A+
\end{itemize}

Với cách ghép này, hệ thống sử dụng 4 loadcell 50kg (2 cặp), tạo thành 2 cụm cảm biến độc lập cho bên trái và bên phải, mỗi cụm có khả năng chịu tải tổng cộng 100kg.

\subsection{Module HX711 và giao thức truyền thông}

HX711 là IC chuyển đổi tương tự sang số (ADC) 24-bit được thiết kế chuyên dụng cho các ứng dụng cân điện tử. Các đặc tính kỹ thuật chính:

\begin{itemize}
    \item Độ phân giải: 24-bit (tương đương khoảng 16.7 triệu mức lượng tử hóa)
    \item Tốc độ lấy mẫu: 10 SPS (Samples Per Second) hoặc 80 SPS, tùy thuộc vào mức logic của chân RATE
    \item Bộ khuếch đại tích hợp: Độ lợi (Gain) có thể chọn 32, 64, hoặc 128
    \item Giao tiếp: Giao thức nối tiếp đồng bộ 2 dây (DOUT và SCK)
    \item Nguồn cấp: 2.6V đến 5.5V
\end{itemize}

Giao thức truyền thông của HX711 hoạt động như sau: Vi điều khiển tạo xung clock trên chân SCK và đọc dữ liệu từ chân DOUT. Mỗi lần đọc, HX711 truyền 24 bit dữ liệu ADC, sau đó 1-3 xung clock bổ sung để chọn kênh và độ lợi cho lần đọc tiếp theo.

\subsection{Thư viện HX711\_ADC và cơ chế Non-blocking}

Một trong những quyết định kỹ thuật quan trọng của dự án là sử dụng thư viện \texttt{HX711\_ADC} của tác giả Olav Kallhovd[2]  thay vì thư viện \texttt{HX711} chuẩn (của Bogde). Sự khác biệt cốt lõi nằm ở cơ chế đọc dữ liệu:

\textbf{Thư viện HX711 chuẩn (Blocking):}
\begin{itemize}
    \item Hàm chính: \texttt{scale.get\_units(n)}
    \item Cơ chế: Khi gọi hàm, vi điều khiển \textbf{dừng lại và chờ} cho đến khi HX711 hoàn thành chuyển đổi
    \item Thời gian chờ: Ở tốc độ 10Hz, mỗi lần đọc mất 100ms. Nếu lấy trung bình 5 mẫu (\texttt{get\_units(5)}), thời gian chờ lên đến 500ms
    \item Hậu quả: Trong thời gian chờ, các lệnh điều khiển động cơ không được thực thi, gây hiện tượng động cơ chạy giật cục hoặc dừng hẳn
\end{itemize}

\textbf{Thư viện HX711\_ADC (Non-blocking):}
\begin{itemize}
    \item Hàm chính: \texttt{LoadCell.update()} và \texttt{LoadCell.getData()}
    \item Cơ chế: Hàm \texttt{update()} chỉ kiểm tra xem có dữ liệu mới hay không. Nếu chưa có, hàm trả về ngay lập tức (tốn vài micro-giây). Nếu có dữ liệu mới, hàm đọc và lưu vào biến nội bộ
    \item Hàm \texttt{getData()} lấy giá trị từ biến nội bộ ra một cách tức thì, không cần chờ đợi
    \item Lợi ích: Vi điều khiển có thể thực hiện các tác vụ khác (như điều khiển động cơ) trong khi chờ dữ liệu từ cảm biến
\end{itemize}

Sự khác biệt này có ý nghĩa quyết định đối với hiệu năng hệ thống. Với kiến trúc Non-blocking, hàm \texttt{stepper.runSpeed()} có thể được gọi liên tục trong vòng lặp chính mà không bị gián đoạn bởi việc đọc cảm biến, đảm bảo động cơ bước hoạt động mượt mà ở tốc độ cao.

\section{Động cơ bước và driver TB6600}

\subsection{Nguyên lý hoạt động của động cơ bước}

Động cơ bước (Stepper Motor) là loại động cơ điện chuyển đổi các xung điện rời rạc thành chuyển động quay theo từng bước góc cố định. Khác với động cơ DC thông thường (có tốc độ phụ thuộc vào điện áp), vị trí và tốc độ của động cơ bước được xác định hoàn toàn bởi số lượng và tần số của các xung điều khiển.

Động cơ bước lai (Hybrid Stepper Motor) -- loại phổ biến nhất trong các ứng dụng công nghiệp và được sử dụng trong dự án này (Nema 17) -- kết hợp ưu điểm của động cơ bước nam châm vĩnh cửu và động cơ bước biến từ trở. Cấu tạo gồm:

\textbf{Stator:} Chứa các cuộn dây được quấn theo cặp (Phase A và Phase B cho động cơ lưỡng cực). Khi có dòng điện chạy qua, các cuộn dây tạo ra từ trường.

\textbf{Rotor:} Gồm lõi nam châm vĩnh cửu được bọc bởi hai đĩa răng lệch pha nhau. Kết hợp với răng trên stator, cấu trúc này cho phép góc bước nhỏ (thường 1.8°, tương đương 200 bước/vòng).

Nguyên lý hoạt động: Khi dòng điện trong các cuộn dây thay đổi theo trình tự xác định, từ trường stator quay theo, kéo rotor quay theo từng bước. Mỗi bước tương ứng với một góc cố định:

\begin{equation}
\theta_{step} = \frac{360°}{N_{steps}}
\label{eq:step_angle}
\end{equation}

trong đó $N_{steps}$ là số bước trên một vòng quay (200 cho động cơ 1.8°).

\subsection{Chế độ vi bước (Microstepping) và ảnh hưởng đến hiệu năng}

Vi bước là kỹ thuật điều khiển dòng điện trong các cuộn dây theo dạng sóng sin/cosin thay vì dạng bước vuông. Điều này cho phép chia nhỏ mỗi bước đầy đủ thành nhiều bước nhỏ hơn.

Số bước trên mỗi vòng quay khi sử dụng vi bước:

\begin{equation}
N_{micro} = N_{full} \times k
\label{eq:microstep}
\end{equation}

trong đó $N_{full} = 200$ bước/vòng (cho động cơ 1.8°) và $k$ là hệ số vi bước (1, 2, 4, 8, 16, 32...).

Với chế độ 1/16 microstep được sử dụng trong dự án:
\begin{equation}
N_{micro} = 200 \times 16 = 3200 \text{ bước/vòng}
\end{equation}

\textbf{Ưu điểm của vi bước:}
\begin{itemize}
    \item Chuyển động mượt mà hơn, giảm rung động và tiếng ồn
    \item Độ phân giải vị trí cao hơn
    \item Giảm hiện tượng cộng hưởng ở một số dải tốc độ
\end{itemize}

\textbf{Nhược điểm và thách thức:}
\begin{itemize}
    \item Yêu cầu tần số xung điều khiển cao hơn để đạt cùng tốc độ quay
    \item Tăng tải xử lý cho vi điều khiển
    \item Momen xoắn giảm nhẹ so với chế độ full-step
\end{itemize}

\textbf{Phân tích ràng buộc thời gian thực:}

Xét yêu cầu tốc độ 300 RPM (5 vòng/giây):
\begin{itemize}
    \item Ở chế độ Full-step: Tần số xung = $200 \times 5 = 1000$ Hz. Khoảng cách giữa các bước = 1000 $\mu$s
    \item Ở chế độ 1/16 Microstep: Tần số xung = $3200 \times 5 = 16000$ Hz. Khoảng cách giữa các bước = 62.5 $\mu$s
\end{itemize}

Con số 62.5 $\mu$s là ``ngân sách thời gian'' (time budget) tối đa mà vi điều khiển có để hoàn thành mọi tác vụ giữa hai lần tạo xung. Nếu bất kỳ tác vụ nào (đọc cảm biến, tính toán PID, giao tiếp Serial) chiếm thời gian lớn hơn ngưỡng này, hệ thống sẽ vi phạm ràng buộc thời gian thực và động cơ sẽ mất bước.

\subsection{Driver TB6600 và cấu hình điều khiển}

TB6600 là driver công suất cao cho động cơ bước, được thiết kế để điều khiển các động cơ Nema 17 và Nema 23. Thông số kỹ thuật:

\begin{itemize}
    \item Điện áp làm việc: 9-42V DC
    \item Dòng điện tối đa: 4A/pha (có thể điều chỉnh bằng DIP switch)
    \item Hỗ trợ vi bước: Full, 1/2, 1/4, 1/8, 1/16, 1/32
    \item Tín hiệu điều khiển: PUL+ (xung bước), DIR+ (chiều quay), ENA+ (kích hoạt)
    \item Cách ly quang học giữa tín hiệu điều khiển và mạch công suất
\end{itemize}

Giao thức điều khiển đơn giản: Mỗi xung trên chân PUL làm động cơ quay một vi bước. Mức logic trên chân DIR quyết định chiều quay (HIGH = thuận, LOW = nghịch). Chân ENA thường được bỏ trống hoặc nối với mức logic phù hợp để luôn kích hoạt driver.

\subsection{Thư viện AccelStepper và cơ chế Polling}

Thư viện AccelStepper [3] điều khiển động cơ bước theo cơ chế Polling, yêu cầu gọi hàm \texttt{runSpeed()} liên tục trong vòng lặp chính.

Hàm cốt lõi \texttt{runSpeed()} hoạt động như sau (mã giả):

\begin{lstlisting}[style=arduino]
boolean AccelStepper::runSpeed() {
    unsigned long time = micros();
    if (time >= _nextStepTime) {
        step(_direction);  // Thuc hien buoc
        _nextStepTime = time + _stepInterval;
        return true;
    }
    return false;  // Chua den luc, khong lam gi
}
\end{lstlisting}

Thiết kế này đặt ra yêu cầu quan trọng: \textbf{Hàm \texttt{runSpeed()} phải được gọi với tần số cao hơn nhiều so với tần số bước của động cơ}. Nếu động cơ cần bước mỗi 62.5 $\mu$s (ở 1/16 microstep, 300 RPM), thì \texttt{runSpeed()} cần được gọi ít nhất mỗi 30 $\mu$s để đảm bảo độ chính xác thời gian.

Thư viện cũng cung cấp các hàm khác như \texttt{run()} (có gia tốc), \texttt{runToPosition()} và \texttt{runToNewPosition()} (chạy đến vị trí đích). Tuy nhiên, hai hàm sau là \textbf{blocking} -- chúng chứa vòng lặp nội bộ và không trả về cho đến khi động cơ đạt vị trí đích. Trong dự án này, \texttt{runSpeed()} được sử dụng trong vòng lặp chính để đảm bảo tính non-blocking.

\section{Vi điều khiển Arduino}

\subsection{Kiến trúc phần cứng ATmega328P}

Arduino Uno/Nano sử dụng vi điều khiển ATmega328P của Atmel (nay thuộc Microchip). Đây là vi điều khiển 8-bit kiến trúc AVR với các thông số:

\begin{itemize}
    \item Tần số xung nhịp: 16 MHz (chu kỳ lệnh 62.5 ns)
    \item Bộ nhớ Flash (chương trình): 32 KB
    \item Bộ nhớ SRAM (dữ liệu): 2 KB
    \item Bộ nhớ EEPROM: 1 KB
    \item Chân I/O số: 14 (trong đó 6 chân hỗ trợ PWM)
    \item Chân đầu vào analog: 6 (ADC 10-bit)
    \item Giao tiếp: UART, SPI, I2C
    \item Timer: 2 timer 8-bit, 1 timer 16-bit
\end{itemize}

Với tần số 16 MHz, vi điều khiển có thể thực thi khoảng 16 triệu lệnh đơn giản mỗi giây. Tuy nhiên, các thao tác phức tạp như phép tính dấu phẩy động, giao tiếp Serial, hay đọc ADC tiêu tốn nhiều chu kỳ xung nhịp hơn.

\subsection{Mô hình lập trình Arduino}

Arduino sử dụng mô hình lập trình đơn giản với hai hàm chính:

\texttt{setup()}: Được gọi một lần khi khởi động, dùng để khởi tạo các thành phần phần cứng và phần mềm.

\texttt{loop()}: Được gọi lặp đi lặp lại vô hạn sau khi \texttt{setup()} hoàn thành. Đây là nơi chứa logic chính của chương trình.


\subsection{Vấn đề Blocking I/O trong giao tiếp Serial}

Giao tiếp Serial (UART) là nguồn gây blocking phổ biến nhất trong các chương trình Arduino. Phân tích chi tiết cơ chế hoạt động:

\textbf{Bộ đệm truyền (TX Buffer):}

Arduino sử dụng bộ đệm vòng (ring buffer) với kích thước mặc định 64 byte để chứa dữ liệu chờ gửi. Khi gọi \texttt{Serial.print()}, dữ liệu được sao chép vào buffer. Nếu buffer còn trống, hàm trả về ngay lập tức (non-blocking). Một trình phục vụ ngắt (ISR) chạy ngầm sẽ lấy từng byte từ buffer và gửi ra chân TX.

\textbf{Hiện tượng Buffer Overflow:}

Vấn đề xảy ra khi tốc độ ghi dữ liệu vào buffer cao hơn tốc độ gửi ra ngoài. Tốc độ gửi bị giới hạn bởi Baud Rate. Ở 115200 baud (tốc độ được sử dụng trong hệ thống), thời gian gửi 1 byte:

\begin{equation}
t_{byte} = \frac{10 \text{ bits}}{115200 \text{ bps}} \approx 86.8 \text{ } \mu\text{s}
\label{eq:uart_time}
\end{equation}

(10 bits = 1 start bit + 8 data bits + 1 stop bit)

Khi buffer đầy (64 byte), hàm \texttt{Serial.write()} chuyển sang chế độ blocking -- chờ đợi cho đến khi có chỗ trống trong buffer. Trong thời gian chờ, CPU không thể thực hiện các tác vụ khác.

\textbf{Tính toán thiệt hại thời gian:}

Giả sử chương trình in dòng lệnh 25 ký tự mỗi vòng lặp, và buffer đã đầy. Thời gian blocking:

\begin{equation}
T_{delay} \approx 25 \times 86.8 \text{ } \mu\text{s} = 2.17 \text{ ms}
\end{equation}

Trong 2.17 ms này:
\begin{itemize}
    \item Hàm \texttt{runSpeed()} không được gọi
    \item Động cơ (yêu cầu xung mỗi 62.5 $\mu$s) bỏ lỡ: $\frac{2170}{62.5} \approx 35$ xung
    \item Tốc độ thực tế giảm từ 16000 bước/s xuống còn khoảng 461 bước/s
\end{itemize}

Mặc dù baudrate 115200 đã giảm đáng kể thời gian blocking so với 9600 baud (nhanh hơn 12 lần), việc in Serial liên tục trong vòng lặp vẫn gây ra hiện tượng động cơ bước ``chậm và giật cục''.

\textbf{Giải pháp Time-Slicing và lý do chọn chu kỳ 100ms:}

Thay vì in mỗi vòng lặp, hệ thống chỉ in thông tin giám sát mỗi 100ms. Lựa chọn này dựa trên các yếu tố:

\begin{itemize}
    \item \textbf{Khả năng nhận thức của con người:} Mắt người chỉ nhận biết thay đổi ở tần số 10--25Hz. Với 100ms (10 lần/giây), người dùng có thể theo dõi dễ dàng mà không bị ``nhòe'' thông tin.
    
    \item \textbf{Tải CPU:} Mỗi dòng in khoảng 50 ký tự, tốn $50 \times 86.8\mu s = 4.34ms$. Với chu kỳ 100ms, việc in chỉ chiếm $4.34/100 = 4.3\%$ thời gian CPU, còn lại 95.7\% cho điều khiển.
    
    \item \textbf{Đồng bộ với PID:} Chu kỳ PID là 20ms, nên 100ms = 5 chu kỳ PID. Mỗi lần in thể hiện kết quả sau 5 lần tính toán PID, giúp debug hiệu quả.
    
    \item \textbf{Tiêu chuẩn công nghiệp:} 100ms là chu kỳ logging phổ biến trong các hệ thống nhúng thời gian thực, cân bằng giữa độ chi tiết và hiệu năng.
\end{itemize}

\section{Thuật toán điều khiển PID}

\subsection{Mô hình toán học của bộ điều khiển PID}

PID (Proportional-Integral-Derivative) là thuật toán điều khiển vòng kín phổ biến nhất trong công nghiệp[7]. Bộ điều khiển PID tính toán tín hiệu điều khiển $u(t)$ dựa trên sai số $e(t)$ giữa giá trị đặt (Setpoint) và giá trị thực tế (Process Variable):

\begin{equation}
u(t) = K_p \cdot e(t) + K_i \cdot \int_0^t e(\tau) \, d\tau + K_d \cdot \frac{de(t)}{dt}
\label{eq:pid_continuous}
\end{equation}

trong đó:
\begin{itemize}
    \item $u(t)$: Tín hiệu điều khiển (output)
    \item $e(t) = SP - PV$: Sai số (error)
    \item $K_p$: Hệ số khuếch đại tỷ lệ (Proportional gain)
    \item $K_i$: Hệ số khuếch đại tích phân (Integral gain)
    \item $K_d$: Hệ số khuếch đại vi phân (Derivative gain)
\end{itemize}

\subsection{Vai trò của từng thành phần}

\textbf{Thành phần tỷ lệ (P):}

Tạo ra tín hiệu điều khiển tỷ lệ thuận với sai số hiện tại:
\begin{equation}
u_P = K_p \cdot e(t)
\end{equation}

$K_p$ càng lớn, hệ thống phản ứng càng nhanh với sai số. Tuy nhiên, nếu $K_p$ quá lớn, hệ thống có thể dao động hoặc mất ổn định. Thành phần P đơn thuần không thể triệt tiêu hoàn toàn sai số xác lập (steady-state error).

\textbf{Thành phần tích phân (I):}

Tích lũy sai số theo thời gian:
\begin{equation}
u_I = K_i \cdot \int_0^t e(\tau) \, d\tau
\end{equation}

Thành phần này giúp triệt tiêu sai số xác lập bằng cách tích lũy các sai số nhỏ theo thời gian. Tuy nhiên, $K_i$ quá lớn có thể gây hiện tượng vọt lố (overshoot) và làm chậm đáp ứng của hệ thống. Ngoài ra, cần chú ý hiện tượng ``windup'' khi tích phân tích lũy quá lớn trong các tình huống bão hòa.

\textbf{Thành phần vi phân (D):}

Dự đoán xu hướng thay đổi của sai số:
\begin{equation}
u_D = K_d \cdot \frac{de(t)}{dt}
\end{equation}

Thành phần này phản ứng với tốc độ thay đổi của sai số, giúp ``phanh'' hệ thống khi sai số đang giảm nhanh, từ đó giảm vọt lố và dao động. Nhược điểm là nhạy cảm với nhiễu tần số cao trong tín hiệu đo lường.

\subsection{Dạng rời rạc của PID cho hệ thống số}

Trong thực tế, vi điều khiển làm việc với tín hiệu rời rạc. Thuật toán PID được rời rạc hóa với chu kỳ lấy mẫu $T_s$:

\begin{equation}
u[k] = K_p \cdot e[k] + K_i \cdot T_s \sum_{j=0}^{k} e[j] + K_d \cdot \frac{e[k] - e[k-1]}{T_s}
\label{eq:pid_discrete}
\end{equation}

Thư viện PID\_v1 [4] triển khai dạng rời rạc với các tính năng anti-windup và derivative kick prevention.

\subsection{Phương pháp tinh chỉnh tham số PID}

Có nhiều phương pháp tinh chỉnh (tuning) tham số PID, từ các phương pháp giải tích (Ziegler-Nichols, Cohen-Coon) đến các phương pháp thử nghiệm. Trong dự án này, phương pháp thử-sai (Trial and Error) được áp dụng:

\textbf{Bước 1:} Đặt $K_i = K_d = 0$. Tăng dần $K_p$ cho đến khi hệ thống bắt đầu dao động liên tục quanh điểm cân bằng.

\textbf{Bước 2:} Giảm $K_p$ xuống khoảng 60-70\% giá trị gây dao động.

\textbf{Bước 3:} Tăng dần $K_d$ để giảm dao động và vọt lố. Thành phần D đặc biệt hiệu quả cho hệ thống có quán tính (như khối lượng đối trọng).

\textbf{Bước 4:} Nếu còn sai số xác lập (hệ thống không về đúng điểm cân bằng), thêm $K_i$ với giá trị nhỏ.

\textbf{Bước 5:} Lặp lại các bước trên để tinh chỉnh.

\section{Lập trình thời gian thực cho hệ thống nhúng}

\subsection{Khái niệm hệ thống thời gian thực}

Hệ thống thời gian thực (Real-time System) là hệ thống mà tính đúng đắn của kết quả không chỉ phụ thuộc vào giá trị logic của phép tính, mà còn phụ thuộc vào thời điểm kết quả được tạo ra. Trong ngữ cảnh điều khiển động cơ bước:

\begin{itemize}
    \item \textbf{Deadline:} Mỗi xung điều khiển phải được tạo ra đúng thời điểm (trong phạm vi jitter cho phép)
    \item \textbf{Hậu quả vi phạm deadline:} Động cơ mất bước, chạy giật cục, hoặc dừng hẳn
    \item \textbf{Loại hệ thống:} Soft real-time (vi phạm deadline gây suy giảm chất lượng, không gây hỏng hóc nghiêm trọng)
\end{itemize}

\subsection{Blocking vs Non-blocking I/O}

\textbf{Blocking I/O:} Khi thực hiện một thao tác I/O (đọc cảm biến, gửi dữ liệu Serial), CPU chờ đợi cho đến khi thao tác hoàn thành. Trong thời gian chờ, không có tác vụ nào khác được thực hiện.

\textbf{Non-blocking I/O:} Thao tác I/O được khởi tạo và trả về ngay lập tức. CPU có thể thực hiện các tác vụ khác trong khi chờ I/O hoàn thành. Khi I/O sẵn sàng, CPU được thông báo (qua polling hoặc interrupt).

Trong dự án này, các giải pháp non-blocking được áp dụng:
\begin{itemize}
    \item Thư viện HX711\_ADC với hàm \texttt{update()} non-blocking
    \item Giới hạn tần suất in Serial (mỗi 100ms thay vì mỗi vòng lặp)
    \item Sử dụng Baud Rate cao (115200) để giảm thời gian blocking khi buffer đầy
    \item Kiểm tra \texttt{Serial.availableForWrite()} trước khi gửi dữ liệu lớn
\end{itemize}

\subsection{Cơ chế Time-Slicing với millis()}

Time-Slicing là kỹ thuật phân chia thời gian CPU cho các tác vụ khác nhau dựa trên đồng hồ hệ thống. Trong Arduino, hàm \texttt{millis()} trả về số mili-giây kể từ khi khởi động.

Cấu trúc Time-Slicing điển hình:

\begin{lstlisting}[style=arduino]
unsigned long t_task1 = 0;
unsigned long t_task2 = 0;

void loop() {
    // Tac vu nen - chay moi vong lap
    stepper.runSpeed();
    LoadCell.update();

    // Tac vu 1 - chay moi 20ms
    if (millis() - t_task1 >= 20) {
        // Doc cam bien, tinh PID
        t_task1 = millis();
    }

    // Tac vu 2 - chay moi 100ms
    if (millis() - t_task2 >= 100) {
        // In thong tin Serial
        t_task2 = millis();
    }
}
\end{lstlisting}

Cơ chế này cho phép:
\begin{itemize}
    \item Tác vụ ưu tiên cao (\texttt{runSpeed()}) được gọi liên tục
    \item Tác vụ điều khiển (PID) chạy với tần số cố định (50Hz)
    \item Tác vụ giám sát (Serial) chạy với tần số thấp hơn (10Hz) để không ảnh hưởng đến các tác vụ quan trọng
\end{itemize}

\subsection{Vấn đề Pulse Starvation trong điều khiển động cơ bước}

Pulse Starvation (đói xung) là hiện tượng động cơ bước không nhận đủ xung điều khiển do CPU bận thực hiện các tác vụ khác. Hậu quả:

\begin{itemize}
    \item \textbf{Giảm tốc độ thực tế:} Thay vì 16000 bước/s, động cơ có thể chỉ đạt vài trăm bước/s
    \item \textbf{Mất đồng bộ từ trường:} Rotor không theo kịp từ trường stator, gây mất momen hoặc quay ngược
    \item \textbf{Rung lắc và tiếng ồn:} Xung không đều gây kích thích cộng hưởng cơ học
\end{itemize}

Để tránh Pulse Starvation:
\begin{itemize}
    \item Loại bỏ hoặc giảm thiểu các hàm blocking trong vòng lặp chính
    \item Đảm bảo thời gian thực thi của mỗi vòng lặp nhỏ hơn khoảng cách giữa các xung yêu cầu
    \item Sử dụng thư viện điều khiển động cơ dựa trên ngắt Timer (như FastAccelStepper) nếu cần tốc độ rất cao
\end{itemize}

\subsection{Kỹ thuật Deadzone và Hysteresis trong điều khiển}

\textbf{Deadzone (Vùng chết):}

Là vùng giá trị sai số mà hệ thống không phản ứng. Trong dự án này, Deadzone được đặt $\pm$100g:
\begin{itemize}
    \item Nếu $|e| \leq 100$g: Động cơ dừng, PID tắt
    \item Nếu $|e| > 100$g: PID hoạt động, động cơ di chuyển
\end{itemize}

Mục đích: Tránh động cơ chạy liên tục để bù các sai số nhỏ do nhiễu cảm biến hoặc rung động cơ học.

\textbf{Hysteresis (Độ trễ):}

Là kỹ thuật sử dụng hai ngưỡng khác nhau cho việc bật và tắt một chế độ:
\begin{itemize}
    \item Ngưỡng bật (Start threshold): 110g (= 100g + 10g hysteresis)
    \item Ngưỡng tắt (Stop threshold): 90g (= 100g - 10g hysteresis)
\end{itemize}

Logic hoạt động:
\begin{itemize}
    \item Nếu đang dừng và $|e| > 110$g: Bật chế độ cân bằng
    \item Nếu đang chạy và $|e| < 90$g: Tắt chế độ cân bằng
\end{itemize}

Mục đích: Tránh hiện tượng bật/tắt liên tục (chattering) khi sai số dao động quanh ngưỡng Deadzone.

\textbf{Minimum Speed Threshold (Ngưỡng tốc độ tối thiểu):}

Động cơ bước có vùng tốc độ thấp gây cộng hưởng và rung lắc. Giải pháp:
\begin{itemize}
    \item Nếu PID tính ra tốc độ $> 0$ nhưng $< 4000$ bước/s: Ép tốc độ lên 4000 bước/s
    \item Nếu PID tính ra tốc độ $= 0$ hoặc $\geq 4000$: Giữ nguyên
\end{itemize}

Điều này đảm bảo khi động cơ cần chạy, nó chạy ở tốc độ đủ cao để vượt qua vùng cộng hưởng.

%======================================================================
%======================================================================
% CHƯƠNG 3: THIẾT KẾ HỆ THỐNG (ĐÃ SỬA LỖI FLOAT)
%======================================================================
\chapter{Thiết kế hệ thống}

Chương này trình bày chi tiết quá trình thiết kế hệ thống khung đế cân bằng trọng tâm, bao gồm: phân tích yêu cầu thiết kế, thiết kế cơ khí, thiết kế mạch điện, và thiết kế phần mềm điều khiển.

\section{Phân tích yêu cầu thiết kế}

\subsection{Yêu cầu chức năng}

Dựa trên mục tiêu đề tài và phân tích ứng dụng thực tế, hệ thống cần đáp ứng các yêu cầu chức năng sau:

\textbf{F1 - Phát hiện độ lệch trọng tâm:} Hệ thống phải có khả năng đo lường sự chênh lệch trọng lượng giữa hai bên khung (trái và phải) với độ phân giải tối thiểu 10g.

\textbf{F2 - Bù đắp độ lệch tự động:} Khi phát hiện độ lệch vượt ngưỡng cho phép, hệ thống phải tự động di chuyển khối đối trọng để bù đắp, đưa trọng tâm về vị trí cân bằng.

\textbf{F3 - Xác định điểm gốc (Homing):} Khi khởi động, hệ thống phải có khả năng tự động xác định vị trí tham chiếu của khối đối trọng thông qua công tắc hành trình.

\textbf{F4 - Bảo vệ hành trình:} Hệ thống phải ngăn chặn khối đối trọng di chuyển vượt quá giới hạn cơ khí.

\textbf{F5 - Giám sát hoạt động:} Cung cấp khả năng theo dõi các thông số hoạt động thông qua giao diện Serial.

\subsection{Yêu cầu phi chức năng}

\textbf{NF1 - Kích thước:} Khung đế có kích thước 35$\times$35cm, phù hợp với robot di động cỡ nhỏ và vừa.

\textbf{NF2 - Thời gian đáp ứng:} Hệ thống phải bắt đầu di chuyển đối trọng trong vòng 100ms sau khi phát hiện độ lệch.

\textbf{NF3 - Độ ổn định:} Động cơ bước phải hoạt động mượt mà, không bị giật cục hay mất bước.

\textbf{NF4 - Độ chính xác cân bằng:} Sau khi cân bằng, độ lệch còn lại phải nằm trong vùng $\pm$100g.

\subsection{Ràng buộc thiết kế}

Quá trình thiết kế phải tuân thủ các ràng buộc: sử dụng linh kiện phổ biến tại Việt Nam (Arduino, Nema 17, TB6600, Loadcell 50kg, HX711); khung cơ khí dùng nhôm định hình 20$\times$20mm; và tốc độ tối đa của động cơ bị giới hạn khoảng 15000 bước/giây do giới hạn của thư viện AccelStepper.

\section{Thiết kế cơ khí}

\subsection{Tổng quan cấu trúc cơ khí}

Hệ thống cơ khí bao gồm các thành phần chính: khung đế hình vuông làm từ nhôm định hình, cơ cấu di chuyển đối trọng gồm vitme và thanh trượt, động cơ bước gắn ở một đầu vitme, các cụm loadcell gắn ở bốn góc khung, và công tắc hành trình để xác định điểm gốc. Bảng 3.1 trình bày thông số khung nhôm định hình.

\begin{table}[H]{Thông số khung nhôm định hình}
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Thông số} & \textbf{Giá trị} \\
\hline
Kích thước tổng thể & 350 $\times$ 350 mm \\
Tiết diện thanh nhôm & 20 $\times$ 20 mm \\
Vật liệu & Hợp kim nhôm 6063-T5 \\
Phương pháp liên kết & Ke góc vuông + bu-lông M5 \\
Khối lượng khung & Khoảng 1.2 kg \\
\hline
\end{tabular}
\end{table}

Lý do lựa chọn nhôm định hình: độ cứng vững cao nhờ tiết diện rỗng với các gân tăng cứng bên trong; dễ gia công và lắp ráp; linh hoạt nhờ rãnh chữ T cho phép gắn linh kiện ở bất kỳ vị trí nào; nhẹ với tỷ trọng 2.7 g/cm³; và khả năng tái sử dụng cao.

\subsection{Cơ cấu vitme - thanh trượt}

Cơ cấu di chuyển đối trọng sử dụng truyền động vitme-đai ốc kết hợp với thanh trượt tròn dẫn hướng. Bảng 3.2 trình bày thông số vitme.

\begin{table}[H]{Thông số vitme}
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Thông số} & \textbf{Giá trị} \\
\hline
Đường kính danh nghĩa & 8 mm \\
Bước ren (Pitch) & 2 mm \\
Chiều dài làm việc & 250 mm \\
Loại & Vitme bi hoặc vitme thang \\
\hline
\end{tabular}
\end{table}

Bước ren 2mm có nghĩa mỗi vòng quay của động cơ, khối trượt di chuyển 2mm. Tính toán tốc độ di chuyển tối đa với chế độ 1/16 microstep (3200 bước/vòng) và tốc độ xung tối đa 15000 bước/giây: $n_{max} = 15000/3200 \times 60 = 281$ RPM, suy ra $v_{max} = 281 \times 2 / 60 = 9.4$ mm/s. Tốc độ này khá ổn, để di chuyển hết hành trình 120mm cần khoảng 13 giây.

Thanh trượt tròn đường kính 8mm, chiều dài 280mm, vật liệu thép mạ cứng, song song với vitme. Thanh trượt có chức năng dẫn hướng cho khối trượt di chuyển thẳng và chống xoay.

\subsection{Bố trí cảm biến Loadcell}

Hệ thống sử dụng 4 loadcell 50kg được bố trí ở bốn góc khung, ghép thành 2 cụm (trái và phải). Cụm trái gồm 2 loadcell ở góc trái-trước và trái-sau, ghép thành cầu Wheatstone đầy đủ. Cụm phải gồm 2 loadcell ở góc phải-trước và phải-sau. Mỗi cụm kết nối với một module HX711 riêng biệt.

\subsection{Giới hạn hành trình}

Hành trình di chuyển của khối đối trọng được xác định từ vị trí tâm (0): giới hạn trái là -120mm (tương ứng -192000 bước), giới hạn phải là +110mm (tương ứng +176000 bước). Công tắc hành trình được lắp đặt ở vị trí giới hạn phải (+110mm) để xác định điểm gốc khi thực hiện Homing.

\section{Thiết kế mạch điện}

\subsection{Sơ đồ khối hệ thống}

Hệ thống điện tử bao gồm các khối chức năng chính: Khối cảm biến (2 cụm Loadcell kết nối với 2 module HX711), Khối xử lý trung tâm (Arduino Uno), Khối điều khiển động cơ (Driver TB6600 và động cơ bước Nema 17), Khối nguồn (12V cho động cơ, 5V cho mạch điều khiển), và Khối giới hạn hành trình (công tắc hành trình). Hình 3.1 thể hiện sơ đồ khối hệ thống.

\begin{figure}[H]{Sơ đồ khối hệ thống điện tử}
\centering
\includegraphics[width=0.95\textwidth]{hinh/so-do-khoi.png}
\end{figure}

\subsection{Danh sách linh kiện điện tử}

Bảng 3.3 liệt kê các linh kiện điện tử sử dụng trong hệ thống.

\begin{table}[H]{Danh sách linh kiện điện tử}
\centering
\begin{tabular}{|c|l|l|c|}
\hline
\textbf{STT} & \textbf{Linh kiện} & \textbf{Thông số} & \textbf{SL} \\
\hline
1 & Vi điều khiển Arduino & Uno hoặc Nano (ATmega328P) & 1 \\
2 & Module HX711 & ADC 24-bit cho loadcell & 2 \\
3 & Loadcell & 50kg, 3 dây (half-bridge) & 4 \\
4 & Driver TB6600 & 9-42V, 4A max & 1 \\
5 & Động cơ bước & Nema 17, 1.8°/bước, 1.5A & 1 \\
6 & Công tắc hành trình & Micro switch với cần gạt & 1 \\
7 & Nguồn xung & 12V 5A & 1 \\
\hline
\end{tabular}
\end{table}

\subsection{Sơ đồ kết nối chi tiết}

Kết nối giữa Arduino và các module HX711 được thể hiện trong Bảng 3.4.

\begin{table}[H]{Kết nối Arduino với các module HX711}
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Module} & \textbf{Chân HX711} & \textbf{Chân Arduino} & \textbf{Ghi chú} \\
\hline
HX711 Trái & VCC & 5V & Nguồn cấp \\
HX711 Trái & GND & GND & Mass chung \\
HX711 Trái & DT (DOUT) & Pin 4 & Dữ liệu \\
HX711 Trái & SCK & Pin 5 & Xung clock \\
\hline
HX711 Phải & VCC & 5V & Nguồn cấp \\
HX711 Phải & GND & GND & Mass chung \\
HX711 Phải & DT (DOUT) & Pin 6 & Dữ liệu \\
HX711 Phải & SCK & Pin 7 & Xung clock \\
\hline
\end{tabular}
\end{table}

Kết nối giữa Arduino và driver TB6600 được thể hiện trong Bảng 3.5.

\begin{table}[H]{Kết nối Arduino với driver TB6600}
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Chân TB6600} & \textbf{Chân Arduino} & \textbf{Chức năng} \\
\hline
PUL+ & Pin 8 & Tín hiệu xung bước \\
PUL- & GND & Mass tín hiệu \\
DIR+ & Pin 9 & Tín hiệu chiều quay \\
DIR- & GND & Mass tín hiệu \\
ENA+ & Không kết nối & Kích hoạt driver \\
ENA- & Không kết nối & (Bỏ trống = luôn bật) \\
\hline
\end{tabular}
\end{table}

Kết nối công tắc hành trình: chân NO (Normally Open) nối với Pin 10 của Arduino sử dụng INPUT\_PULLUP, chân COM nối với GND. Logic hoạt động: khi chưa nhấn, Pin 10 ở mức HIGH; khi nhấn (khối trượt chạm công tắc), Pin 10 xuống mức LOW.

\subsection{Cấu hình Driver TB6600}

Cấu hình DIP Switch trên TB6600: dòng điện đặt 1.5A theo bảng tra của TB6600, chế độ vi bước 1/16 (3200 pulse/rev) với SW4=ON, SW5=ON, SW6=OFF. Lưu ý cấu hình có thể khác nhau giữa các phiên bản TB6600, cần tham khảo datasheet của nhà sản xuất cụ thể.

\subsection{Sơ đồ nguyên lý mạch điện}

Hình 3.2 thể hiện sơ đồ nguyên lý mạch điện chi tiết của toàn bộ hệ thống, bao gồm các kết nối giữa Arduino, HX711, TB6600, động cơ bước, công tắc hành trình và nguồn điện.

\begin{figure}[H]{Sơ đồ nguyên lý mạch điện hệ thống}
\centering
\includegraphics[width=\textwidth]{hinh/so-do-nguyen-ly.png}
\end{figure}

\subsection{Thiết kế nguồn điện}

Hệ thống sử dụng hai nguồn điện riêng biệt. Nguồn 12V/5A cấp cho driver TB6600 và động cơ, công suất 60W dư so với yêu cầu của Nema 17. Nguồn 5V cấp từ cổng USB của Arduino cho Arduino, HX711 và các cảm biến, dòng tiêu thụ ước tính dưới 500mA. Lưu ý quan trọng: GND của nguồn 12V và GND của Arduino phải được nối chung để đảm bảo tín hiệu điều khiển hoạt động đúng.

\subsection{Xử lý nhiễu điện từ}

Động cơ bước và driver công suất có thể tạo ra nhiễu điện từ ảnh hưởng đến tín hiệu loadcell. Các biện pháp giảm nhiễu bao gồm: tách biệt nguồn cho động cơ và mạch điều khiển; xoắn dây tín hiệu loadcell theo dạng twisted pair; giữ dây kết nối ngắn nhất có thể (dưới 50cm); có thể thêm tụ điện 100nF gần chân nguồn của HX711; và áp dụng lọc phần mềm bằng cách làm tròn giá trị đọc (quantization).

\section{Thiết kế phần mềm}

\subsection{Kiến trúc phần mềm tổng quan}

Phần mềm điều khiển được thiết kế theo kiến trúc Superloop với Time-Slicing, đảm bảo tính non-blocking và đáp ứng các ràng buộc thời gian thực. Kiến trúc này chia thành ba tầng nhiệm vụ với độ ưu tiên và tần suất khác nhau:

Nhiệm vụ nền chạy mỗi vòng lặp (khoảng 10 $\mu$s) bao gồm gọi hàm LoadCell.update() để kiểm tra dữ liệu mới một cách non-blocking và gọi hàm stepper.runSpeed() để tạo xung nếu đến thời điểm.

Nhiệm vụ điều khiển chạy mỗi 20ms (tần số 50Hz) bao gồm đọc giá trị cảm biến, tính toán sai số, xử lý logic Deadzone và Hysteresis, tính toán PID, và cập nhật tốc độ động cơ.

Nhiệm vụ giám sát chạy mỗi 100ms (tần số 10Hz) bao gồm in các thông số ra Serial và hiển thị trạng thái hệ thống.

\subsection{Quy trình Homing}

Quy trình Homing xác định điểm gốc của hệ thống với độ chính xác cao thông qua phương pháp hai giai đoạn, được minh họa trong Hình 3.3.

\begin{figure}[H]{Lưu đồ quy trình Homing}
\centering
\includegraphics[width=0.65\textwidth]{hinh/luu-do-homing.png}
\end{figure}

\textbf{Giai đoạn 1 - Tìm nhanh:} Di chuyển khối trượt về phía công tắc hành trình với tốc độ cao 8000 bước/s. Khi chạm công tắc (Pin 10 xuống LOW), dừng ngay lập tức và ghi nhận vị trí tạm thời là MAX\_POS\_RIGHT.

\textbf{Giai đoạn 2 - Lùi ra và tìm chậm:} Lùi ra 5mm để nhả công tắc, kiểm tra công tắc đã nhả (Pin 10 lên HIGH), sau đó di chuyển chậm trở lại với tốc độ 6000 bước/s cho đến khi chạm công tắc lần thứ hai. Vị trí chạm lần hai là điểm gốc chính xác.

\textbf{Giai đoạn 3 - Di chuyển về tâm:} Thiết lập vị trí hiện tại là MAX\_POS\_RIGHT (+110mm), di chuyển đến vị trí 0 (tâm khung), và chờ 5 giây để loadcell ổn định trước khi bắt đầu cân bằng.

\subsection{Logic điều khiển PID với Deadzone và Hysteresis}

Logic điều khiển được thiết kế để tránh các vấn đề phổ biến trong hệ thống cân bằng, được minh họa trong Hình 3.4.

\begin{figure}[H]{Lưu đồ thuật toán điều khiển PID}
\centering
\includegraphics[width=0.75\textwidth]{hinh/luu-do-pid.png}
\end{figure}

\textbf{Vấn đề 1 - Dao động quanh điểm cân bằng (Hunting):} Nếu không có vùng chết, khi độ lệch về gần 0, PID vẫn tiếp tục điều chỉnh, gây ra dao động liên tục. Giải pháp là áp dụng Deadzone $\pm$100g.

\textbf{Vấn đề 2 - Bật/tắt liên tục (Chattering):} Nếu chỉ dùng một ngưỡng 100g, khi sai số dao động quanh ngưỡng này, hệ thống sẽ bật/tắt liên tục. Giải pháp là áp dụng Hysteresis $\pm$10g với ngưỡng bật 110g và ngưỡng tắt 90g.

\textbf{Vấn đề 3 - Động cơ rung ở tốc độ thấp:} Động cơ bước có các vùng tốc độ gây cộng hưởng và rung lắc. Giải pháp là áp dụng ngưỡng tốc độ tối thiểu 4000 bước/s.

\subsection{Xử lý giới hạn hành trình mềm}

Ngoài công tắc hành trình vật lý ở vị trí +110mm, phần mềm còn kiểm tra giới hạn mềm (soft limits) để ngăn khối trượt va chạm vào hai đầu. Nếu vị trí hiện tại đã đạt giới hạn trái và tốc độ đang âm (muốn đi tiếp sang trái), hệ thống ép tốc độ về 0. Tương tự cho giới hạn phải.

\subsection{Các tham số cấu hình}

Bảng 3.6 tổng hợp các tham số cấu hình của phần mềm.

\begin{table}[H]{Bảng tổng hợp các tham số cấu hình phần mềm}
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Tham số} & \textbf{Giá trị} & \textbf{Ý nghĩa} \\
\hline
MICROSTEP & 16 & Chế độ vi bước 1/16 \\
STEPS\_PER\_MM & 1600 & Số bước trên 1mm \\
MAX\_POS\_RIGHT & +176000 & Giới hạn phải (bước) \\
MAX\_POS\_LEFT & -192000 & Giới hạn trái (bước) \\
\hline
MAX\_SPEED\_PID & 8000 & Tốc độ tối đa (bước/s) \\
MOTOR\_ACCEL & 16000 & Gia tốc (bước/s²) \\
MIN\_SPEED\_THRESHOLD & 4000 & Tốc độ tối thiểu \\
\hline
Kp & 40.0 & Hệ số tỷ lệ PID \\
Ki & 0 & Hệ số tích phân PID \\
Kd & 0 & Hệ số vi phân PID \\
\hline
ACCEPTABLE\_RANGE & 100.0 & Vùng chết (g) \\
HYSTERESIS\_GAP & 10.0 & Độ trễ (g) \\
STEP\_SIZE & 10.0 & Độ chia quantization (g) \\
\hline
PID\_INTERVAL & 20 & Chu kỳ tính PID (ms) \\
PRINT\_INTERVAL & 100 & Chu kỳ in Serial (ms) \\
\hline
\end{tabular}
\end{table}

\subsection{Quy trình hiệu chuẩn Loadcell}

Trước khi sử dụng, mỗi cụm loadcell cần được hiệu chuẩn để xác định hệ số chuyển đổi. Quy trình gồm 5 bước: nạp chương trình hiệu chuẩn từ ví dụ của thư viện HX711\_ADC; đảm bảo không có tải trên loadcell và thực hiện lệnh tare về 0; đặt vật chuẩn có khối lượng đã biết (ví dụ 500g) lên loadcell; điều chỉnh hệ số hiệu chuẩn cho đến khi giá trị đọc được bằng khối lượng vật chuẩn; và ghi nhận hệ số hiệu chuẩn để cập nhật vào chương trình chính.

Trong dự án này, hệ số hiệu chuẩn đã xác định là CALIB\_LEFT = -53.13 và CALIB\_RIGHT = -55.36. Dấu âm là do cách lắp đặt loadcell theo chiều nén.

%======================================================================
% CHƯƠNG 4: THỰC NGHIỆM VÀ ĐÁNH GIÁ  
% Dựa trên số liệu thực nghiệm: Kp=20/30/40, vật chuẩn 210g
% LƯU Ý: File này đã sửa lỗi cellcolor
%======================================================================

\chapter{Thực nghiệm và đánh giá}

Chương này trình bày chi tiết các kết quả thực nghiệm thu được từ hệ thống khung cân bằng trọng tâm. Dữ liệu được thu thập trực tiếp từ Serial Monitor trong quá trình vận hành thực tế, bao gồm: kiểm tra độ chính xác cảm biến, so sánh hiệu năng với các giá trị $K_p$ khác nhau, và thử nghiệm tổng hợp với nhiều kịch bản tải trọng.

\section{Triển khai hệ thống}

\subsection{Môi trường thử nghiệm}

Hệ thống được triển khai và thử nghiệm trong điều kiện phòng thí nghiệm với các thông số:

\begin{itemize}
    \item Nhiệt độ phòng: 25--30°C
    \item Mặt sàn: Phẳng, cứng (gạch men)
    \item Nguồn điện: Ổn định 220V AC, chuyển đổi sang 12V DC và 5V DC
    \item Không có rung động ngoại lai đáng kể
\end{itemize}

\subsection{Các tham số cấu hình thử nghiệm}

Bảng \ref{tab:test_params} tổng hợp các tham số cấu hình được sử dụng trong toàn bộ quá trình thử nghiệm.

\begin{table}[H]{Tham số cấu hình hệ thống trong thử nghiệm}
\centering
\label{tab:test_params}
\begin{tabular}{|l|c|l|}
\hline
\textbf{Tham số} & \textbf{Giá trị} & \textbf{Ý nghĩa} \\
\hline
\texttt{ACCEPTABLE\_RANGE} & 100.0 g & Vùng chết (Deadzone) \\
\texttt{HYSTERESIS\_GAP} & 10.0 g & Độ trễ Hysteresis \\
Ngưỡng bật [RUN] & $>$ 110 g & 100 + 10 \\
Ngưỡng tắt [OK] & $<$ 90 g & 100 -- 10 \\
\hline
\texttt{MIN\_SPEED\_THRESHOLD} & 4000 bước/s & Tốc độ tối thiểu \\
\texttt{MAX\_SPEED\_PID} & 8000 bước/s & Tốc độ tối đa \\
\texttt{MOTOR\_ACCEL} & 16000 bước/s² & Gia tốc động cơ \\
\hline
\texttt{STEP\_SIZE} & 10.0 g & Độ chia quantization \\
\texttt{PID\_INTERVAL} & 20 ms & Chu kỳ tính PID \\
\hline
\end{tabular}
\end{table}

\section{Kiểm tra độ chính xác cảm biến Loadcell}

Trước khi tiến hành các thử nghiệm chính, cần đảm bảo hai cụm loadcell (Trái và Phải) đã được hiệu chuẩn chính xác.

\subsection{Phương pháp kiểm tra}

\begin{itemize}
    \item \textbf{Vật chuẩn}: Quả cân 210 gram
    \item \textbf{Quy trình}: Đặt vật lên cụm loadcell Trái, ghi nhận giá trị ổn định; sau đó đặt lên cụm Phải, ghi nhận giá trị
    \item \textbf{Tiêu chí đánh giá}: Sai số $<$ 5\%, không có hiện tượng crosstalk (đọc chéo)
\end{itemize}

\subsection{Kết quả đo}

Bảng \ref{tab:sensor_accuracy} trình bày kết quả kiểm tra độ chính xác cảm biến.

\begin{table}[H]{Kết quả kiểm tra độ chính xác cảm biến với vật chuẩn 210g}
\centering
\label{tab:sensor_accuracy}
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{Vị trí đặt vật} & \textbf{Giá trị L (g)} & \textbf{Giá trị R (g)} & \textbf{Sai số} & \textbf{Kết quả} \\
\hline
Bên TRÁI & 210 & 0 & 0\% & \textbf{Đạt} \\
Bên PHẢI & 0 & 210 & 0\% & \textbf{Đạt} \\
\hline
\end{tabular}
\end{table}

\textbf{Nhận xét}: Cả hai cụm loadcell đều đọc chính xác giá trị 210g với sai số 0\%. Không có hiện tượng crosstalk -- khi đặt vật lên một bên, bên còn lại đọc giá trị 0. Giá trị đọc ổn định trong suốt thời gian đo, xác nhận hệ thống cảm biến sẵn sàng cho các thử nghiệm tiếp theo.

\section{Thử nghiệm so sánh các giá trị hệ số $K_p$}

Mục đích của thử nghiệm này là xác định giá trị $K_p$ tối ưu cho bộ điều khiển PID. Ba giá trị $K_p$ được thử nghiệm là 20, 30 và 40, với cùng điều kiện: đặt vật nặng khoảng 200g lên bên TRÁI, theo dõi quá trình cân bằng từ khi bắt đầu cho đến khi đạt trạng thái [OK].

\subsection{Kết quả chi tiết từng giá trị $K_p$}

\textbf{Thử nghiệm với $K_p = 20$}

Dữ liệu thu thập từ Serial Monitor:
\begin{itemize}
    \item Thời điểm bắt đầu: 14:30:08 -- Độ lệch --120g, chuyển sang [RUN]
    \item Độ lệch đỉnh: --220g
    \item Tốc độ động cơ: 4000--4400 bước/s (công thức: $Speed = K_p \times |Lệch| = 20 \times 220 = 4400$)
    \item Thời điểm kết thúc: 14:30:33 -- Độ lệch --80g, chuyển về [OK]
    \item \textbf{Thời gian xác lập: khoảng 25 giây}
\end{itemize}

\textbf{Thử nghiệm với $K_p = 30$}

\begin{itemize}
    \item Thời điểm bắt đầu: 14:11:58 -- Độ lệch --130g, chuyển sang [RUN]
    \item Độ lệch đỉnh: --220g
    \item Tốc độ động cơ đỉnh: 6600 bước/s ($Speed = 30 \times 220 = 6600$)
    \item Thời điểm kết thúc: 14:12:19 -- Độ lệch --80g, chuyển về [OK]
    \item \textbf{Thời gian xác lập: khoảng 21 giây}
\end{itemize}

\textbf{Thử nghiệm với $K_p = 40$}

\begin{itemize}
    \item Thời điểm bắt đầu: 13:39:20 -- Độ lệch --140g, chuyển sang [RUN]
    \item Độ lệch đỉnh: --220g
    \item Tốc độ động cơ đỉnh: 8000 bước/s ($Speed = 40 \times 220 = 8800$, bị giới hạn bởi \texttt{MAX\_SPEED})
    \item Thời điểm kết thúc: 13:39:36 -- Độ lệch --80g, chuyển về [OK]
    \item \textbf{Thời gian xác lập: khoảng 16 giây}
\end{itemize}

\subsection{Bảng so sánh tổng hợp}

Bảng \ref{tab:kp_comparison} so sánh hiệu năng hệ thống với các giá trị $K_p$ khác nhau.

\begin{table}[H]{So sánh hiệu năng với các giá trị $K_p$ khác nhau}
\centering
\label{tab:kp_comparison}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Chỉ tiêu} & \textbf{$K_p = 20$} & \textbf{$K_p = 30$} & \textbf{$K_p = 40$} \\
\hline
Độ lệch đỉnh (g) & --220 & --220 & --220 \\
Tốc độ đỉnh (bước/s) & 4400 & 6600 & 8000 \\
\textbf{Thời gian xác lập (s)} & khoảng 25 & khoảng 21 & \textbf{khoảng 16} \\
Độ lệch cuối (g) & --80 [OK] & --80 [OK] & --80 [OK] \\
Overshoot & Không & Không & Không \\
\hline
\end{tabular}
\end{table}

\subsection{Biểu đồ so sánh thời gian xác lập}

Hình \ref{fig:kp_settling_time} minh họa mối quan hệ giữa giá trị $K_p$ và thời gian xác lập.

\begin{figure}[H]{So sánh thời gian xác lập với các giá trị $K_p$ khác nhau}
\centering
\begin{tikzpicture}
\begin{axis}[
    ybar,
    bar width=25pt,
    xlabel={Giá trị $K_p$},
    ylabel={Thời gian xác lập (giây)},
    symbolic x coords={Kp=20, Kp=30, Kp=40},
    xtick=data,
    ymin=0, ymax=30,
    nodes near coords,
    nodes near coords align={vertical},
    enlarge x limits=0.25,
    width=0.7\textwidth,
    height=0.45\textwidth,
]
\addplot[fill=blue!60] coordinates {(Kp=20, 25) (Kp=30, 21) (Kp=40, 16)};
\end{axis}
\end{tikzpicture}
\label{fig:kp_settling_time}
\end{figure}

\subsection{Biểu đồ diễn biến độ lệch theo thời gian}

Hình \ref{fig:response_curves} minh họa đường cong đáp ứng của hệ thống với ba giá trị $K_p$.

\begin{figure}[H]{Đường cong đáp ứng -- Diễn biến độ lệch theo thời gian với các giá trị $K_p$}
\centering
\begin{tikzpicture}
\begin{axis}[
    xlabel={Thời gian (giây)},
    ylabel={Độ lệch tuyệt đối (g)},
    xmin=0, xmax=28,
    ymin=0, ymax=250,
    legend pos=north east,
    grid=major,
    width=0.85\textwidth,
    height=0.5\textwidth,
]
% Kp = 20 (chậm nhất)
\addplot[color=red, thick, mark=none] coordinates {
    (0, 0) (1, 120) (2, 220) (3, 220) (4, 210) (5, 210) (6, 200) (7, 200)
    (8, 190) (9, 190) (10, 180) (11, 180) (12, 170) (13, 170) (14, 160)
    (15, 160) (16, 150) (17, 150) (18, 140) (19, 140) (20, 130) (21, 120)
    (22, 110) (23, 100) (24, 90) (25, 80)
};
% Kp = 30 (trung bình)
\addplot[color=blue, thick, mark=none] coordinates {
    (0, 0) (1, 130) (2, 220) (3, 220) (4, 200) (5, 180) (6, 180) (7, 170)
    (8, 160) (9, 160) (10, 150) (11, 140) (12, 140) (13, 130) (14, 120)
    (15, 120) (16, 110) (17, 100) (18, 100) (19, 90) (20, 90) (21, 80)
};
% Kp = 40 (nhanh nhất)
\addplot[color=green!70!black, thick, mark=none] coordinates {
    (0, 0) (1, 140) (2, 220) (3, 210) (4, 190) (5, 170) (6, 150) (7, 140)
    (8, 130) (9, 120) (10, 110) (11, 100) (12, 100) (13, 90) (14, 90) 
    (15, 80) (16, 80)
};
% Đường ngưỡng Deadzone
\addplot[color=gray, dashed, thick] coordinates {(0, 90) (28, 90)};
\node at (axis cs:26,95) {\small Ngưỡng tắt};

\legend{$K_p = 20$, $K_p = 30$, $K_p = 40$}
\end{axis}
\end{tikzpicture}
\label{fig:response_curves}
\end{figure}

\textbf{Nhận xét}: $K_p = 40$ cho thời gian đáp ứng nhanh nhất (khoảng 16 giây), nhanh hơn 36\% so với $K_p = 20$. Tất cả các giá trị $K_p$ đều đạt trạng thái cân bằng với độ lệch cuối --80g (trong vùng Deadzone $\pm$100g). Không có hiện tượng overshoot ở bất kỳ giá trị $K_p$ nào, cho thấy hệ thống ổn định.

\section{Thử nghiệm tổng hợp với nhiều kịch bản tải}

Thử nghiệm này đánh giá khả năng đáp ứng của hệ thống với nhiều thay đổi tải liên tiếp, mô phỏng điều kiện vận hành thực tế của robot khi gắp/thả vật. Sử dụng $K_p = 40$ (giá trị tối ưu từ thử nghiệm trước).

\subsection{Kịch bản thử nghiệm}

Bảng \ref{tab:comprehensive_test} trình bày timeline của thử nghiệm tổng hợp.

\begin{table}[H]{Timeline thử nghiệm tổng hợp với nhiều kịch bản tải}
\centering
\label{tab:comprehensive_test}
\begin{tabular}{|c|l|c|c|}
\hline
\textbf{Thời gian} & \textbf{Hành động} & \textbf{Độ lệch (g)} & \textbf{Trạng thái} \\
\hline
13:38:46 & Đặt vật ở TÂM sau Homing & L:100, R:110 $\rightarrow$ +10 & \textbf{[OK]} \\
13:39:19 & +200g bên TRÁI & --220 $\rightarrow$ --80 & [RUN]$\rightarrow$[OK] \\
khoảng 13:39:50 & Nhấc 200g khỏi TRÁI & Motor đảo chiều & [RUN]$\rightarrow$[OK] \\
khoảng 13:40:20 & +200g bên PHẢI & Lệch dương lớn & [RUN]$\rightarrow$[OK] \\
khoảng 13:40:50 & +80g bên TRÁI (chồng tải) & Giảm lệch nhẹ & [RUN]$\rightarrow$[OK] \\
khoảng 13:41:05 & Nhấc 80g khỏi TRÁI & --110 $\rightarrow$ --80 & [RUN]$\rightarrow$[OK] \\
13:41:14 & Kết thúc thử nghiệm & L:150, R:70 $\rightarrow$ --80 & \textbf{[OK]} \\
\hline
\end{tabular}
\end{table}

\subsection{Biểu đồ diễn biến thử nghiệm tổng hợp}

Hình \ref{fig:comprehensive_timeline} minh họa diễn biến độ lệch và trạng thái hệ thống trong thử nghiệm tổng hợp.

\begin{figure}[H]{Diễn biến độ lệch trong thử nghiệm tổng hợp}
\centering
\begin{tikzpicture}
\begin{axis}[
    xlabel={Thời gian (giây từ khi bắt đầu)},
    ylabel={Độ lệch (g)},
    xmin=0, xmax=150,
    ymin=-250, ymax=250,
    grid=major,
    width=0.95\textwidth,
    height=0.5\textwidth,
    legend pos=south east,
    ytick={-200,-150,-100,-50,0,50,100,150,200},
]
% Đường độ lệch
\addplot[color=blue, thick, mark=none] coordinates {
    (0, 10) (10, 10) (33, 10)
    (35, -120) (37, -220) (40, -200) (45, -150) (50, -80)
    (55, -80) (64, -80)
    (66, 50) (68, 150) (75, 80)
    (80, 80) (94, 80)
    (96, 180) (100, 150) (105, 80)
    (110, 80) (124, 80)
    (126, 50) (130, -30) (135, -80)
    (140, -80) (148, -80)
};

% Đường ngưỡng
\addplot[color=red, dashed] coordinates {(0, 110) (150, 110)};
\addplot[color=red, dashed] coordinates {(0, -110) (150, -110)};

% Annotations
\node[anchor=south, font=\footnotesize] at (axis cs:37,-220) {+200g Trái};
\node[anchor=south, font=\footnotesize] at (axis cs:68,150) {Nhấc 200g};
\node[anchor=south, font=\footnotesize] at (axis cs:98,180) {+200g Phải};
\node[anchor=north, font=\footnotesize] at (axis cs:128,-30) {+80g Trái};

\legend{Độ lệch, Ngưỡng bật ($\pm$110g)}
\end{axis}
\end{tikzpicture}
\label{fig:comprehensive_timeline}
\end{figure}

\subsection{Phân tích kết quả}

\textbf{Xác nhận hoạt động của cơ chế Hysteresis}:
\begin{itemize}
    \item Hệ thống chuyển sang [RUN] khi $|Lệch| > 110$g (quan sát: --120g $\rightarrow$ [RUN])
    \item Hệ thống chuyển về [OK] khi $|Lệch| < 90$g (quan sát: --80g $\rightarrow$ [OK])
    \item Khoảng cách 20g (từ 90g đến 110g) ngăn hiện tượng bật/tắt liên tục
\end{itemize}

\textbf{Đánh giá khả năng xử lý}:
\begin{itemize}
    \item \textit{Phát hiện thay đổi tải}: Chính xác, phản ứng ngay khi vượt ngưỡng
    \item \textit{Xác định hướng điều chỉnh}: Đúng chiều (âm $\rightarrow$ motor chạy phải, dương $\rightarrow$ motor chạy trái)
    \item \textit{Xử lý tải chồng}: Hoạt động tốt khi thêm 80g trong khi đang có 200g bên kia
    \item \textit{Đảo chiều}: Mượt mà, không giật khi đổi hướng di chuyển
\end{itemize}

\section{Phân tích hiệu năng hệ thống}

\subsection{Hiệu năng bộ điều khiển PID}

Với bộ tham số PID đã tinh chỉnh ($K_p = 40$, $K_i = 0$, $K_d = 0$), Bảng \ref{tab:pid_performance} tổng hợp các chỉ số hiệu năng.

\begin{table}[H]{Tổng hợp hiệu năng bộ điều khiển PID}
\centering
\label{tab:pid_performance}
\begin{tabular}{|l|c|}
\hline
\textbf{Thông số} & \textbf{Giá trị đo được} \\
\hline
Thời gian xác lập (với $K_p = 40$) & khoảng 16 giây \\
Độ vọt lố (Overshoot) & 0\% \\
Sai số xác lập & $<$ 90g (trong Deadzone) \\
Độ ổn định & Ổn định, không dao động \\
Thời gian phát hiện thay đổi tải & $<$ 100 ms \\
\hline
\end{tabular}
\end{table}

\textbf{Lý do chọn $K_i = 0$ và $K_d = 0$}:
\begin{itemize}
    \item Thành phần $K_i$ không cần thiết vì Deadzone $\pm$100g đã chấp nhận sai số nhỏ
    \item Thành phần $K_d$ có thể khuếch đại nhiễu từ cảm biến (dù đã có Quantization 10g)
    \item Bộ điều khiển P thuần túy đủ đáp ứng yêu cầu với hệ thống có quán tính thấp
\end{itemize}

\subsection{Hiệu quả cơ chế Deadzone và Hysteresis}

Hình \ref{fig:hysteresis_diagram} minh họa cơ chế Hysteresis trong hệ thống.

\begin{figure}[H]{Sơ đồ cơ chế Hysteresis với ngưỡng bật $\pm$110g và ngưỡng tắt $\pm$90g}
\centering
\begin{tikzpicture}[scale=0.9]
% Trục
\draw[->] (-5,0) -- (5,0) node[right] {Độ lệch (g)};
\draw[->] (0,-0.5) -- (0,3) node[above] {Trạng thái};

% Các mốc
\draw[thick] (-4.4,0.1) -- (-4.4,-0.1) node[below] {\small --110};
\draw[thick] (-3.6,0.1) -- (-3.6,-0.1) node[below] {\small --90};
\draw[thick] (3.6,0.1) -- (3.6,-0.1) node[below] {\small +90};
\draw[thick] (4.4,0.1) -- (4.4,-0.1) node[below] {\small +110};

% Vùng Deadzone
\fill[green!20] (-3.6,0) rectangle (3.6,2.5);
\node at (0,1.2) {\textbf{DEADZONE}};
\node at (0,0.7) {\small [OK] -- Motor dừng};

% Vùng RUN
\fill[red!20] (-5,0) rectangle (-4.4,2.5);
\fill[red!20] (4.4,0) rectangle (5,2.5);
\node[rotate=90] at (-4.7,1.2) {\tiny [RUN]};
\node[rotate=90] at (4.7,1.2) {\tiny [RUN]};

% Vùng Hysteresis
\fill[yellow!30] (-4.4,0) rectangle (-3.6,2.5);
\fill[yellow!30] (3.6,0) rectangle (4.4,2.5);
\node[rotate=90, font=\tiny] at (-4,1.2) {Hysteresis};
\node[rotate=90, font=\tiny] at (4,1.2) {Hysteresis};

% Mũi tên chuyển trạng thái
\draw[->, thick, blue] (-4.6,2.2) -- (-4.2,2.2) node[midway, above, font=\tiny] {Bật};
\draw[->, thick, blue] (-3.8,2.2) -- (-3.4,2.2) node[midway, above, font=\tiny] {Tắt};

\end{tikzpicture}
\label{fig:hysteresis_diagram}
\end{figure}

\textbf{Lợi ích của Deadzone và Hysteresis}:
\begin{itemize}
    \item \textit{Tiết kiệm năng lượng}: Động cơ dừng hoàn toàn khi đã cân bằng (Speed = 0)
    \item \textit{Giảm mài mòn cơ khí}: Không chạy qua chạy lại liên tục quanh điểm cân bằng
    \item \textit{Tránh hunting}: Ngưỡng bật ($>$110g) khác ngưỡng tắt ($<$90g) ngăn dao động
    \item \textit{Giảm tiếng ồn}: Hệ thống yên tĩnh khi ở trạng thái cân bằng
\end{itemize}

\subsection{Hiệu quả thiết kế Non-blocking}

Bảng \ref{tab:blocking_comparison} so sánh hiệu năng giữa thiết kế Non-blocking và Blocking.

\begin{table}[H]{So sánh hiệu năng Non-blocking và Blocking}
\centering
\label{tab:blocking_comparison}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Tiêu chí} & \textbf{Non-blocking} & \textbf{Blocking} \\
\hline
Tần số gọi \texttt{runSpeed()} & khoảng 100 kHz & khoảng 40 Hz \\
Tốc độ motor tối đa & \textbf{8000 bước/s} & $<$100 bước/s \\
Độ mượt chuyển động & \textbf{Rất mượt} & Giật cục, rít \\
Chu kỳ PID & \textbf{20ms (ổn định)} & Không ổn định \\
Thời gian đọc Loadcell & Song song & Tuần tự (25ms block) \\
\hline
\end{tabular}
\end{table}

\section{Đánh giá tổng thể}

\subsection{So sánh với mục tiêu đề ra}

Bảng \ref{tab:goal_comparison} so sánh kết quả thực nghiệm với các mục tiêu đề ra ban đầu.

\begin{table}[H]{So sánh kết quả với mục tiêu đề ra}
\centering
\label{tab:goal_comparison}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Mục tiêu} & \textbf{Yêu cầu} & \textbf{Kết quả} & \textbf{Đánh giá} \\
\hline
Phát hiện độ lệch & Có & Có & \textbf{Đạt} \\
Tự động cân bằng & Có & Có & \textbf{Đạt} \\
Độ chính xác & $\pm$100g & $\pm$80g & \textbf{Vượt} \\
Thời gian đáp ứng & $<$30s & 16--25s & \textbf{Đạt} \\
Hoạt động ổn định & $>$30 phút & $>$30 phút & \textbf{Đạt} \\
Không overshoot & Có & Có (0\%) & \textbf{Đạt} \\
\hline
\end{tabular}
\end{table}

\textbf{Kết luận Chương 4}: Hệ thống đáp ứng đầy đủ các mục tiêu đề ra. Cảm biến loadcell hoạt động chính xác với sai số 0\%. Bộ điều khiển PID với $K_p = 40$ cho thời gian đáp ứng nhanh nhất (khoảng 16 giây). Cơ chế Deadzone và Hysteresis hoạt động hiệu quả, tránh hiện tượng hunting. Thiết kế Non-blocking là yếu tố then chốt giúp động cơ bước hoạt động mượt mà ở tốc độ cao.

%======================================================================
% CHƯƠNG 5: KẾT LUẬN VÀ HƯỚNG PHÁT TRIỂN
%======================================================================

\chapter{Kết luận và hướng phát triển}

\section{Kết luận}

Khóa luận đã hoàn thành việc nghiên cứu, thiết kế và xây dựng hệ thống khung đế robot có khả năng tự động cân bằng trọng tâm sử dụng phương pháp khối lượng di động (Moving Mass). Dựa trên kết quả thực nghiệm chi tiết ở Chương 4, các kết luận được rút ra như sau:

\subsection{Về mặt lý thuyết}

\begin{enumerate}
    \item Phương pháp khối lượng di động kết hợp cảm biến Loadcell là giải pháp phù hợp cho bài toán cân bằng tĩnh và bán tĩnh khi tải thay đổi.
    
    \item Bộ điều khiển P thuần túy ($K_p = 40$, $K_i = 0$, $K_d = 0$) đủ đáp ứng yêu cầu với hệ thống có quán tính thấp và Deadzone hợp lý.
    
    \item Cơ chế Hysteresis với khoảng cách 20g (ngưỡng bật 110g, ngưỡng tắt 90g) hiệu quả trong việc ngăn hiện tượng hunting.
    
    \item Kiến trúc Non-blocking là bắt buộc để tích hợp cảm biến chậm (HX711 khoảng 10--80Hz) với điều khiển động cơ bước tốc độ cao (8000 bước/s).
\end{enumerate}

\subsection{Về mặt thực tiễn}

Bảng \ref{tab:practical_results} tổng hợp các kết quả định lượng từ thực nghiệm.

\begin{table}[H]{Tổng hợp kết quả định lượng từ thực nghiệm}
\centering
\label{tab:practical_results}
\begin{tabular}{|l|c|}
\hline
\textbf{Chỉ tiêu} & \textbf{Kết quả đạt được} \\
\hline
Độ chính xác cảm biến & 0\% sai số với vật chuẩn 210g \\
Thời gian xác lập ($K_p = 40$) & khoảng 16 giây cho tải 200g \\
Độ lệch cuối cùng & $<$ 90g (trong Deadzone $\pm$100g) \\
Overshoot & 0\% (không có) \\
Xử lý thay đổi tải liên tục & Thành công (6 lần trong 2.5 phút) \\
Hoạt động ổn định & $>$ 30 phút liên tục \\
\hline
\end{tabular}
\end{table}

\subsection{Đóng góp của đề tài}

\begin{enumerate}
    \item Đề xuất và triển khai thành công giải pháp cân bằng trọng tâm sử dụng Loadcell -- phương pháp ít được nghiên cứu so với IMU.
    
    \item Xây dựng kiến trúc phần mềm Non-blocking hoàn chỉnh, có thể tái sử dụng cho các dự án tương tự.
    
    \item Cung cấp bộ dữ liệu thực nghiệm chi tiết để so sánh hiệu năng các giá trị $K_p$.
    
    \item Tài liệu hóa đầy đủ quy trình thiết kế, triển khai và tinh chỉnh hệ thống.
\end{enumerate}

\section{Hạn chế}

Bên cạnh các kết quả đạt được, đề tài còn một số hạn chế cần được khắc phục:

\begin{enumerate}
    \item \textbf{Tốc độ đáp ứng}: Thời gian 16--25 giây có thể chưa đủ nhanh cho ứng dụng yêu cầu phản ứng tức thời. Nguyên nhân chính là vitme bước 2mm có tốc độ di chuyển tối đa khoảng 5mm/s.
    
    \item \textbf{Giới hạn tải}: Với công thức $m_{load,max} = 0.69 \times m_{slider}$ (hệ số từ tỷ lệ cánh tay đòn $\frac{120}{175}$), đối trọng 200g chỉ bù được khoảng 137g.
    
    \item \textbf{Phạm vi ứng dụng}: Chỉ cân bằng theo một trục (Trái-Phải), chưa mở rộng cho 2 trục.
    
    \item \textbf{Giao diện}: Chưa có giao diện người dùng trực quan, chỉ giám sát qua Serial Monitor.
    
    \item \textbf{Tích hợp}: Chưa tích hợp thực tế với robot di động để đánh giá hiệu quả trong điều kiện vận hành.
\end{enumerate}

\section{Hướng phát triển}

Dựa trên kết quả và hạn chế của đề tài, các hướng phát triển tiếp theo bao gồm:

\subsection{Cải tiến phần cứng}

\begin{enumerate}
    \item \textbf{Tăng tốc độ di chuyển}: Thay vitme bước 2mm bằng vitme 4--8mm hoặc hệ thống đai răng (belt drive), có thể tăng tốc độ đáp ứng 2--4 lần.
    
    \item \textbf{Mở rộng 2 trục}: Thêm cơ cấu vitme + đối trọng theo trục Trước-Sau để cân bằng hoàn toàn trên mặt phẳng.
    
    \item \textbf{Tăng khả năng chịu tải}: Sử dụng pin/acquy (1--2kg) làm đối trọng di động, có thể bù được độ lệch 690--1380g.
    
    \item \textbf{Nâng cấp vi điều khiển}: Chuyển sang ESP32 hoặc STM32 cho tốc độ xử lý cao hơn, hỗ trợ WiFi/Bluetooth tích hợp.
\end{enumerate}

\subsection{Cải tiến phần mềm}

\begin{enumerate}
    \item \textbf{Thuật toán điều khiển nâng cao}: Nghiên cứu áp dụng LQR (Linear Quadratic Regulator) hoặc MPC (Model Predictive Control) để tối ưu đáp ứng.
    
    \item \textbf{Bộ lọc Kalman}: Tích hợp bộ lọc Kalman để kết hợp dữ liệu từ Loadcell và IMU, tăng tốc độ phản hồi.
    
    \item \textbf{Adaptive PID}: Phát triển PID tự thích nghi, tự động điều chỉnh $K_p$ theo đặc tính tải.
    
    \item \textbf{Giao diện người dùng}: Xây dựng ứng dụng di động hoặc giao diện web để giám sát và điều khiển từ xa.
\end{enumerate}

\subsection{Tích hợp và ứng dụng}

\begin{enumerate}
    \item \textbf{Tích hợp robot thực tế}: Lắp đặt khung cân bằng lên robot di động có cánh tay gắp để đánh giá hiệu quả trong điều kiện vận hành.
    
    \item \textbf{Kết nối ROS}: Tích hợp vào Robot Operating System (ROS) cho điều khiển tổng thể hệ thống robot.
    
    \item \textbf{Ứng dụng công nghiệp}: Phát triển phiên bản với độ bền cao, phù hợp môi trường nhà máy.
\end{enumerate}

\section{Lời kết}

Khóa luận đã hoàn thành mục tiêu đề ra là xây dựng hệ thống khung đế robot có khả năng tự động cân bằng trọng tâm. Kết quả thực nghiệm cho thấy hệ thống hoạt động ổn định, đáp ứng các yêu cầu kỹ thuật với độ chính xác $\pm$80g và thời gian đáp ứng 16--25 giây.

Mặc dù còn một số hạn chế về tốc độ đáp ứng và phạm vi ứng dụng, hệ thống đã chứng minh tính khả thi của phương pháp khối lượng di động kết hợp cảm biến Loadcell. Các kiến thức và kinh nghiệm thu được trong quá trình thực hiện, từ thiết kế cơ khí, điện tử đến lập trình nhúng và điều khiển tự động, là nền tảng quý giá cho việc phát triển các hệ thống robot phức tạp hơn trong tương lai.

Em xin chân thành cảm ơn thầy giáo hướng dẫn ThS. Đặng Anh Việt đã tận tình chỉ bảo và hỗ trợ em trong suốt quá trình thực hiện khóa luận này.

%======================================================================
% TÀI LIỆU THAM KHẢO (10 MỤC THIẾT YẾU)
% Chèn vào cuối khóa luận, sau Chương 5
%======================================================================

\begin{thebibliography}{10}

%----------------------------------------------------------------------
% TIẾNG VIỆT
%----------------------------------------------------------------------
\begin{bibsection}{Tiếng Việt}

\bibitem{phamthanhvu2015}
    Phạm Thanh Vũ,
    \textit{Nghiên cứu các luật điều khiển hiện đại trên mô hình robot cân bằng},
    Luận văn Thạc sĩ, Trường Đại học Công nghệ, Đại học Quốc gia Hà Nội, 2015.

\end{bibsection}

%----------------------------------------------------------------------
% TIẾNG ANH
%----------------------------------------------------------------------
\begin{bibsection}{Tiếng Anh}

% --- Thư viện phần mềm sử dụng trực tiếp ---
\bibitem{kallhovd2017hx711adc}
    O. Kallhovd,
    ``HX711\_ADC: Arduino library for the HX711 24-bit ADC for weight scales'',
    GitHub Repository, 2017.
    Truy cập: https://github.com/olkal/HX711\_ADC

\bibitem{airspayce2023accelstepper}
    M. McCauley,
    ``AccelStepper: Arduino library for stepper motors with acceleration/deceleration'',
    AirSpayce Documentation, 2023.
    Truy cập: https://www.airspayce.com/mikem/arduino/AccelStepper/

\bibitem{pid2012arduino}
    B. Beauregard,
    ``PID\_v1: Arduino PID Library'',
    GitHub Repository, 2012.
    Truy cập: https://github.com/br3ttb/Arduino-PID-Library

% --- Datasheet linh kiện ---
\bibitem{avia2014hx711}
    Avia Semiconductor,
    ``HX711: 24-Bit Analog-to-Digital Converter (ADC) for Weigh Scales'',
    Datasheet, Avia Semiconductor Co., Ltd., 2014.

\bibitem{atmega328p}
    Microchip Technology Inc.,
    ``ATmega328P: 8-bit AVR Microcontroller with 32K Bytes In-System Programmable Flash'',
    Datasheet, Microchip Technology Inc., 2018.

% --- Lý thuyết nền tảng ---
\bibitem{astrom2006pid}
    K. J. Åström and T. Hägglund,
    \textit{Advanced PID Control},
    ISA - The Instrumentation, Systems, and Automation Society, 2006.

\bibitem{siegwart2011mobile}
    R. Siegwart, I. R. Nourbakhsh, and D. Scaramuzza,
    \textit{Introduction to Autonomous Mobile Robots},
    2nd ed., MIT Press, 2011.

% --- Nghiên cứu liên quan ---
\bibitem{mdpi2024sbr}
    MDPI Robotics,
    ``Self-Balancing Mobile Robot: Design, Implementation, and Performance Analysis'',
    \textit{MDPI Robotics},
    vol. 6, no. 3, 2024.

\bibitem{researchgate2018cmg}
    ResearchGate,
    ``Development of a self-balancing robot with a control moment gyroscope'',
    \textit{ResearchGate Publication},
    April 2018.

\end{bibsection}

\end{thebibliography}

%======================================================================
% PHỤ LỤC
%======================================================================
\appendix

\chapter{Mã nguồn chương trình điều khiển}

Dưới đây là mã nguồn hoàn chỉnh của chương trình điều khiển khung cân bằng trọng tâm:

\begin{lstlisting}[style=arduino, caption={Chương trình điều khiển khung cân bằng trọng tâm}]

#include <HX711_ADC.h>     
#include <AccelStepper.h>
#include <PID_v1.h>




const int DOUT_PIN_LEFT = 4; const int SCK_PIN_LEFT = 5;
const int DOUT_PIN_PHAI = 6; const int SCK_PIN_PHAI = 7;
const int STEP_PIN = 8;
const int DIR_PIN = 9;
const int HOME_SWITCH_PIN = 10; 


const int MICROSTEP = 16;       // Driver cài đặt 1/16
const int MOTOR_STEP = 200;     // Động cơ 1.8 độ
const int PITCH = 2;            // Bước ren vitme 2mm

const float STEPS_PER_MM = (float)(MOTOR_STEP * MICROSTEP) / PITCH; 


const long MAX_POS_RIGHT = 110.0 * STEPS_PER_MM; // Giới hạn Phải (+110mm)
const long MAX_POS_LEFT = -120.0 * STEPS_PER_MM; // Giới hạn Trái (-120mm)


const float MAX_SPEED_PID = 8000.0;    // Tốc độ tối đa khi cân bằng
const float MOTOR_ACCEL = 16000.0;      // Gia tốc 
const float HOMING_SPEED_FAST = 8000.0;
const float HOMING_SPEED_SLOW = 6000.0;


const float MIN_SPEED_THRESHOLD = 4000.0; // Tốc độ tối thiểu hiệu quả
const float HYSTERESIS_GAP      = 10.0;  // Khoảng trễ 10g

double Kp = 40.0; 
double Ki = 0; 
double Kd = 0; 
double Setpoint = 0, Input, Output;
PID myPID(&Input, &Output, &Setpoint, Kp, Ki, Kd, DIRECT);

float CALIB_LEFT = -53.13;   
float CALIB_RIGHT = -55.36; 

const float ACCEPTABLE_RANGE = 100.0; // Vùng chết +/- 100g 
const float STEP_SIZE = 10.0;        // Độ chia nhỏ nhất: 10g 


HX711_ADC LoadCellLeft(DOUT_PIN_LEFT, SCK_PIN_LEFT);
HX711_ADC LoadCellRight(DOUT_PIN_PHAI, SCK_PIN_PHAI);
AccelStepper stepper(AccelStepper::DRIVER, STEP_PIN, DIR_PIN);

unsigned long t_pid = 0;   
unsigned long t_print = 0;
long currentPos; 

float fL = 0;           // Lực bên Trái (Đã làm tròn)
float fR = 0;           // Lực bên Phải (Đã làm tròn)
float targetSpeed = 0;
float currentSpeed = 0; // Tốc độ hiện tại
boolean isBalancing = false; 

float rawL, rawR, startThreshold, stopThreshold, rawSpeed;


void setup() {
  Serial.begin(115200); delay(10);
  Serial.println("--- KHOI DONG HE THONG ---");

  pinMode(HOME_SWITCH_PIN, INPUT_PULLUP);

  // 1. Khởi tạo Loadcell
  LoadCellLeft.begin(); LoadCellRight.begin();
  unsigned long stabilizingtime = 1000; 
  boolean _tare = true; // Bắt buộc trừ bì về 0 khi khởi động
  
  LoadCellLeft.start(stabilizingtime, _tare);
  LoadCellRight.start(stabilizingtime, _tare);
  
  if (LoadCellLeft.getTareTimeoutFlag() || LoadCellRight.getTareTimeoutFlag()) {
    Serial.println("LOI: Khong tim thay Loadcell! Kiem tra day ket noi.");
    while(1); // Dừng hệ thống nếu lỗi
  }

  LoadCellLeft.setCalFactor(CALIB_LEFT);
  LoadCellRight.setCalFactor(CALIB_RIGHT);
  Serial.println("Loadcell san sang.");

  myPID.SetMode(AUTOMATIC);
  myPID.SetOutputLimits(-MAX_SPEED_PID, MAX_SPEED_PID);
  myPID.SetSampleTime(20); 

  stepper.setMaxSpeed(MAX_SPEED_PID);
  stepper.setAcceleration(MOTOR_ACCEL); 

  runHomingSequence(); 
}

void loop() {

  LoadCellLeft.update();
  LoadCellRight.update();
  stepper.runSpeed();

  if (millis() > t_pid + 20) {
    
    rawL = LoadCellLeft.getData();
    rawR = LoadCellRight.getData();
    fL = ceil(rawL / STEP_SIZE) * STEP_SIZE;
    fR = ceil(rawR / STEP_SIZE) * STEP_SIZE;
    Input = fR - fL; 


    startThreshold = ACCEPTABLE_RANGE + HYSTERESIS_GAP; 
    stopThreshold  = ACCEPTABLE_RANGE - HYSTERESIS_GAP; 

    if (!isBalancing) {
      if (abs(Input) > startThreshold) {
        isBalancing = true; 
        myPID.SetMode(AUTOMATIC);
      }
    } 
    else {
      if (abs(Input) < stopThreshold) {
        isBalancing = false; 
        Output = 0;
        myPID.SetMode(MANUAL);
      }
    }
    
    if (isBalancing) {
       myPID.Compute();
       rawSpeed = Output;

       if (abs(rawSpeed) > 0.0 && abs(rawSpeed) < MIN_SPEED_THRESHOLD) {

           if (rawSpeed > 0) {
               targetSpeed = MIN_SPEED_THRESHOLD; 
           } else {
               targetSpeed = -MIN_SPEED_THRESHOLD;
           }
       } else {
           
           targetSpeed = rawSpeed;
       }
       
    } else {
       targetSpeed = 0; 
    }
    
    // d. Giới hạn hành trình
    currentPos = stepper.currentPosition();
    if (currentPos <= MAX_POS_LEFT && targetSpeed < 0) targetSpeed = 0;
    if (currentPos >= MAX_POS_RIGHT && targetSpeed > 0) targetSpeed = 0;

    stepper.setSpeed(targetSpeed);
    currentSpeed = targetSpeed; 
    t_pid = millis();
  }

  if (millis() > t_print + 100) {
    Serial.print("L: "); Serial.print(fL, 0);
    Serial.print(" | R: "); Serial.print(fR, 0);
    Serial.print(" | Lech: "); Serial.print(Input, 0); 
    Serial.print(" | Spd: "); Serial.print(currentSpeed, 0);
    
    if (isBalancing) {
       Serial.println(" [RUN]");
    } else {
       Serial.println(" [OK]");
    }

    t_print = millis();
  }
}

void runHomingSequence() {
  Serial.println("[HOMING] Bat dau ve Home...");
  stepper.setAcceleration(MOTOR_ACCEL); 

  stepper.setSpeed(HOMING_SPEED_FAST);
  while (digitalRead(HOME_SWITCH_PIN) == HIGH) { stepper.runSpeed(); }
  stepper.stop();
  stepper.setCurrentPosition(MAX_POS_RIGHT); // Gán mốc tạm

  Serial.println("[HOMING] Lui ra...");
  stepper.moveTo(MAX_POS_RIGHT - (5.0 * STEPS_PER_MM));
  while (stepper.distanceToGo() != 0) { stepper.run(); }

  if (digitalRead(HOME_SWITCH_PIN) == LOW) {
    Serial.println("LOI: Cong tac hanh trinh bi ket!"); 
    while(1);
  }

  stepper.setSpeed(HOMING_SPEED_SLOW);
  while (digitalRead(HOME_SWITCH_PIN) == HIGH) { stepper.runSpeed(); }
  stepper.stop();

  stepper.setCurrentPosition(MAX_POS_RIGHT); 
  stepper.setSpeed(0);

  Serial.println("[HOMING] Ve Tam (0)...");
  stepper.moveTo(0); 
  while (stepper.distanceToGo() != 0) {stepper.run();}

  Serial.println("[HOMING] Da ve tam. Cho on dinh 5s...");
  
  unsigned long waitStart = millis();
  while (millis() - waitStart < 5000) {}
  
  Serial.println("[HOMING] Hoan tat. San sang.");
}
\end{lstlisting}

\end{document}