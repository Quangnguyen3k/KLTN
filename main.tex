\documentclass{uetgraduation}\RequirePackage{float}

% Gói bổ sung cho code listing
\RequirePackage{listings}
\RequirePackage{xcolor}

% Cấu hình hiển thị code Arduino
\lstdefinestyle{arduino}{
    backgroundcolor=\color{white},
    commentstyle=\color{gray},
    keywordstyle=\color{blue}\bfseries,
    numberstyle=\tiny\color{gray},
    stringstyle=\color{orange},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    language=C++,
    morekeywords={setup, loop, pinMode, digitalWrite, digitalRead, analogRead, Serial, HIGH, LOW, INPUT, OUTPUT, INPUT_PULLUP, byte, boolean}
}

\begin{document}

%======================================================================
% THÔNG TIN TRANG BÌA
%======================================================================
\studentname{Nguyễn Vũ Quang}
\title{Xây dựng khung đế robot có khả năng cân bằng trọng tâm}
\documenttype{Khóa luận tốt nghiệp đại học hệ chính quy}
\major{Kỹ thuật điều khiển và tự động hóa}
\year{2025}
\supervisor{ThS. Đặng Anh Việt}
\makecovers

%======================================================================
% LỜI CAM ĐOAN
%======================================================================
\begin{preamble}{Lời cam đoan}
Tôi xin cam đoan đây là công trình nghiên cứu của riêng tôi dưới sự hướng dẫn của ThS. Đặng Anh Việt. Các số liệu, kết quả nêu trong khóa luận là trung thực và chưa từng được ai công bố trong bất kỳ công trình nào khác.

Tôi xin cam đoan rằng mọi sự giúp đỡ cho việc thực hiện khóa luận này đã được cảm ơn và các thông tin trích dẫn trong khóa luận đã được chỉ rõ nguồn gốc.

\vspace{2cm}
\hfill Hà Nội, ngày \hspace{1cm} tháng \hspace{1cm} năm 2025

\hfill \textbf{Sinh viên thực hiện}

\vspace{1.5cm}
\hfill \textbf{Nguyễn Vũ Quang}
\end{preamble}

%======================================================================
% LỜI CẢM ƠN
%======================================================================
\begin{preamble}{Lời cảm ơn}
Để hoàn thành khóa luận tốt nghiệp này, tôi đã nhận được rất nhiều sự giúp đỡ và hỗ trợ từ thầy cô, gia đình và bạn bè.

Trước hết, tôi xin gửi lời cảm ơn chân thành và sâu sắc nhất đến ThS. Đặng Anh Việt -- người đã trực tiếp hướng dẫn, chỉ bảo tận tình và tạo mọi điều kiện thuận lợi cho tôi trong suốt quá trình thực hiện khóa luận.

Tôi xin chân thành cảm ơn các thầy cô giáo trong Khoa Điện tử - Viễn thông, Trường Đại học Công nghệ, Đại học Quốc gia Hà Nội đã trang bị cho tôi những kiến thức quý báu trong suốt thời gian học tập tại trường.

Cuối cùng, tôi xin gửi lời cảm ơn đến gia đình, bạn bè đã luôn động viên, khích lệ tôi trong suốt quá trình học tập và thực hiện khóa luận.

\vspace{2cm}
\hfill Hà Nội, tháng 6 năm 2025

\hfill \textbf{Sinh viên}

\vspace{1.5cm}
\hfill \textbf{Nguyễn Vũ Quang}
\end{preamble}

%======================================================================
% TÓM TẮT
%======================================================================
\begin{preamble}{Tóm tắt}
\textbf{Tóm tắt:} Khóa luận trình bày quá trình nghiên cứu, thiết kế và chế tạo khung đế robot di động có khả năng tự động cân bằng trọng tâm. Hệ thống sử dụng cảm biến lực (Loadcell) kết hợp với module HX711 để đo chênh lệch trọng lượng giữa hai bên khung. Thuật toán điều khiển PID được áp dụng để điều khiển động cơ bước di chuyển khối đối trọng trên cơ cấu vitme, từ đó bù đắp sự mất cân bằng khi tải thay đổi.

Kết quả thực nghiệm cho thấy hệ thống có khả năng phát hiện và bù đắp độ lệch trọng tâm trong phạm vi $\pm$50g với thời gian đáp ứng nhanh. Chương trình điều khiển được viết theo kiến trúc Non-blocking, đảm bảo động cơ bước hoạt động mượt mà ở tốc độ cao mà không bị ảnh hưởng bởi các tác vụ đọc cảm biến hay giao tiếp Serial.

Khóa luận cũng đề xuất các hướng phát triển mở rộng như điều khiển vị trí, tốc độ chuyển dịch và tích hợp vào robot di động thực tế.

\textit{\textbf{Từ khóa:} Cân bằng trọng tâm, Loadcell, PID, Động cơ bước, Arduino, Non-blocking, Robot di động.}
\end{preamble}

%======================================================================
% MỤC LỤC VÀ DANH SÁCH
%======================================================================
\begin{contentlisting}

\tableofcontents
\listoffigures
\listoftables

\begin{contentlistingsection}{Danh sách các từ viết tắt}
\textbf{PID:} Proportional-Integral-Derivative -- Bộ điều khiển vi tích phân tỷ lệ.

\textbf{PWM:} Pulse Width Modulation -- Điều chế độ rộng xung.

\textbf{ADC:} Analog to Digital Converter -- Bộ chuyển đổi tương tự sang số.

\textbf{I2C:} Inter-Integrated Circuit -- Giao thức truyền thông nối tiếp.

\textbf{SPI:} Serial Peripheral Interface -- Giao diện ngoại vi nối tiếp.

\textbf{UART:} Universal Asynchronous Receiver-Transmitter -- Bộ thu phát không đồng bộ.

\textbf{GPIO:} General Purpose Input/Output -- Chân vào/ra đa mục đích.

\textbf{RPM:} Revolutions Per Minute -- Vòng quay trên phút.

\textbf{ISR:} Interrupt Service Routine -- Trình phục vụ ngắt.
\end{contentlistingsection}

\end{contentlisting}

%======================================================================
% CHƯƠNG 1: TỔNG QUAN
%======================================================================
\chapter{Tổng quan}

\section{Đặt vấn đề và lý do chọn đề tài}

Trong những năm gần đây, robot di động (Mobile Robot) đã trở thành một trong những lĩnh vực nghiên cứu và ứng dụng phát triển mạnh mẽ nhất trong ngành tự động hóa. Từ các robot vận chuyển hàng hóa trong nhà máy, robot phục vụ trong nhà hàng, đến các robot thám hiểm địa hình phức tạp -- tất cả đều đòi hỏi khả năng di chuyển ổn định và thích ứng với các điều kiện tải trọng thay đổi.

Một thách thức kỹ thuật quan trọng trong thiết kế robot di động là vấn đề \textbf{cân bằng trọng tâm}. Khi robot mang theo tải trọng hoặc được trang bị cánh tay thao tác (manipulator), trọng tâm của hệ thống sẽ thay đổi theo vị trí và khối lượng của tải. Sự dịch chuyển trọng tâm này gây ra nhiều hệ quả tiêu cực:

\begin{itemize}
    \item \textbf{Giảm ổn định động học:} Robot dễ bị lật hoặc mất cân bằng khi di chuyển trên địa hình không bằng phẳng, đặc biệt khi tải lệch về một phía.
    \item \textbf{Tăng tải không đều lên các bánh xe:} Dẫn đến mài mòn không đồng đều, giảm tuổi thọ cơ cấu truyền động và ảnh hưởng đến độ chính xác điều khiển quỹ đạo.
    \item \textbf{Tăng tiêu hao năng lượng:} Các động cơ dẫn động phải bù đắp momen do tải lệch gây ra, làm giảm hiệu suất và thời gian hoạt động của robot.
    \item \textbf{Ảnh hưởng đến độ chính xác thao tác:} Với robot có cánh tay, sự mất cân bằng của đế ảnh hưởng trực tiếp đến độ chính xác định vị của end-effector.
\end{itemize}

Giải pháp truyền thống cho vấn đề này thường là thiết kế đế robot với trọng tâm thấp và phân bố tải đối xứng. Tuy nhiên, cách tiếp cận này không linh hoạt khi tải trọng thay đổi trong quá trình vận hành. Một giải pháp tiên tiến hơn là sử dụng \textbf{hệ thống cân bằng trọng tâm chủ động} (Active Center of Gravity Balancing System), trong đó một cơ cấu chấp hành sẽ tự động di chuyển khối đối trọng để bù đắp sự thay đổi trọng tâm.

Hệ thống cân bằng trọng tâm chủ động đòi hỏi sự kết hợp của nhiều thành phần: cảm biến đo lường độ lệch, cơ cấu chấp hành di chuyển đối trọng, và thuật toán điều khiển để xác định vị trí đối trọng tối ưu. Đây là một bài toán điều khiển vòng kín điển hình, phù hợp để áp dụng các kiến thức về \textbf{lý thuyết điều khiển tự động}, \textbf{cảm biến và đo lường}, cũng như \textbf{hệ thống nhúng thời gian thực}.

Xuất phát từ nhu cầu thực tiễn và tính ứng dụng cao của vấn đề, đề tài \textit{``Xây dựng khung đế robot có khả năng cân bằng trọng tâm''} được lựa chọn làm khóa luận tốt nghiệp. Đề tài hướng đến việc nghiên cứu, thiết kế và chế tạo một khung đế có khả năng tự động phát hiện và bù đắp độ lệch trọng tâm, tạo nền tảng cho việc phát triển các robot di động ổn định hơn trong tương lai.

\section{Mục tiêu nghiên cứu}

Mục tiêu tổng quát của khóa luận là thiết kế và chế tạo một khung đế robot di động có khả năng tự động cân bằng trọng tâm khi tải trọng thay đổi. Để đạt được mục tiêu này, các mục tiêu cụ thể được xác định như sau:

\subsection{Mục tiêu về nghiên cứu lý thuyết}

Nghiên cứu nguyên lý cân bằng trọng tâm dựa trên lý thuyết momen lực và điều kiện cân bằng tĩnh. Tìm hiểu các phương pháp đo lường độ lệch trọng tâm, trong đó tập trung vào việc sử dụng cảm biến lực (Loadcell) để xác định sự chênh lệch tải trọng giữa các điểm tựa.

Nghiên cứu thuật toán điều khiển PID (Proportional-Integral-Derivative) và phương pháp tinh chỉnh tham số phù hợp với đặc tính của hệ thống cơ điện tử. Đặc biệt, nghiên cứu các kỹ thuật xử lý vùng chết (Deadzone), độ trễ (Hysteresis) để tránh hiện tượng dao động quanh điểm cân bằng.

Nghiên cứu kiến trúc lập trình thời gian thực cho hệ thống nhúng, đảm bảo khả năng đáp ứng nhanh và ổn định của hệ thống điều khiển.

\subsection{Mục tiêu về thiết kế và chế tạo}

Thiết kế khung cơ khí có kích thước phù hợp với robot di động cỡ nhỏ và vừa (khoảng 35$\times$35cm), đảm bảo độ cứng vững và khả năng tích hợp các thành phần điện tử.

Thiết kế cơ cấu di chuyển đối trọng sử dụng động cơ bước kết hợp truyền động vitme, đảm bảo độ chính xác vị trí và khả năng chịu tải.

Thiết kế mạch điện tử điều khiển bao gồm: mạch đọc tín hiệu từ cảm biến lực, mạch điều khiển động cơ bước, và giao tiếp với vi điều khiển.

Chế tạo và lắp ráp hoàn chỉnh mô hình khung đế cân bằng.

\subsection{Mục tiêu về phần mềm điều khiển}

Xây dựng chương trình điều khiển trên nền tảng vi điều khiển Arduino, tích hợp thuật toán PID để tự động điều chỉnh vị trí đối trọng.

Đảm bảo chương trình hoạt động theo kiến trúc Non-blocking (không chặn), cho phép động cơ bước vận hành mượt mà ở tốc độ cao mà không bị ảnh hưởng bởi các tác vụ đọc cảm biến hay giao tiếp.

Phát triển giao diện giám sát thông qua Serial Monitor để theo dõi các thông số hoạt động và hỗ trợ quá trình tinh chỉnh hệ thống.

\subsection{Mục tiêu về thử nghiệm và đánh giá}

Tiến hành thử nghiệm hệ thống với các kịch bản tải trọng khác nhau. Đánh giá các chỉ tiêu: thời gian đáp ứng, độ chính xác cân bằng, độ ổn định, và phạm vi tải trọng có thể bù đắp.

So sánh kết quả thực nghiệm với mục tiêu thiết kế, phân tích các hạn chế và đề xuất hướng cải tiến.

\section{Đối tượng và phạm vi nghiên cứu}

\subsection{Đối tượng nghiên cứu}

Đối tượng nghiên cứu của khóa luận bao gồm các thành phần chính của hệ thống cân bằng trọng tâm:

\textbf{Cảm biến lực Loadcell và module HX711:} Loadcell là cảm biến đo lực dựa trên nguyên lý điện trở biến dạng. Module HX711 là bộ chuyển đổi ADC 24-bit chuyên dụng cho loadcell, có khả năng đọc tín hiệu với độ phân giải cao. Trong dự án này, thư viện HX711\_ADC được sử dụng với ưu điểm hỗ trợ chế độ đọc Non-blocking, cho phép vi điều khiển thực hiện các tác vụ khác trong khi chờ dữ liệu từ cảm biến.

\textbf{Động cơ bước và driver TB6600:} Động cơ bước Nema 17 được sử dụng làm cơ cấu chấp hành, với đặc điểm điều khiển vị trí chính xác theo vòng hở. Driver TB6600 hỗ trợ điều khiển vi bước (microstepping) với các mức 1/2, 1/4, 1/8, 1/16, cho phép tăng độ phân giải và giảm rung động.

\textbf{Vi điều khiển Arduino:} Nền tảng Arduino (chip ATmega328P, tần số 16MHz) được chọn làm bộ xử lý trung tâm do tính phổ biến, dễ lập trình, và có nhiều thư viện hỗ trợ. Thư viện AccelStepper được sử dụng để điều khiển động cơ bước với khả năng điều chỉnh tốc độ và gia tốc mượt mà.

\textbf{Thuật toán điều khiển PID:} Bộ điều khiển PID là thuật toán điều khiển vòng kín phổ biến trong công nghiệp, phù hợp cho các hệ thống yêu cầu độ chính xác và ổn định cao. Thư viện PID\_v1 cho Arduino được sử dụng để triển khai thuật toán.

\textbf{Kỹ thuật lập trình thời gian thực:} Nghiên cứu các vấn đề về độ trễ (latency), blocking I/O, và các giải pháp Non-blocking để đảm bảo hệ thống đáp ứng các ràng buộc thời gian thực.

\subsection{Phạm vi nghiên cứu}

Khóa luận tập trung vào các giới hạn sau:

\textbf{Về không gian:} Hệ thống cân bằng trọng tâm theo \textbf{một trục} (trái-phải). Việc mở rộng sang hai trục được đề cập như hướng phát triển.

\textbf{Về kích thước:} Khung đế có kích thước 35$\times$35cm, phù hợp với các robot di động cỡ nhỏ và vừa. Hành trình di chuyển đối trọng: 120mm về bên trái, 110mm về bên phải (tính từ vị trí tâm).

\textbf{Về tải trọng:} Cảm biến loadcell có tải trọng định mức 50kg mỗi cụm. Khối lượng đối trọng ban đầu là 200g, có thể điều chỉnh tùy theo yêu cầu cân bằng.

\textbf{Về điều khiển:} Sử dụng điều khiển vòng hở cho động cơ bước (không có encoder phản hồi vị trí). Thuật toán PID với vùng chết $\pm$50g -- tức là hệ thống chấp nhận độ lệch trong phạm vi này mà không cần điều chỉnh.

\textbf{Về hiệu năng:} Tốc độ tối đa của động cơ bước bị giới hạn bởi khả năng xử lý của vi điều khiển và đặc tính của thư viện AccelStepper (khoảng 4000 bước/giây trong điều kiện tối ưu).

\section{Phương pháp nghiên cứu}

Khóa luận sử dụng kết hợp các phương pháp nghiên cứu sau:

\subsection{Phương pháp nghiên cứu lý thuyết}

Thu thập và phân tích các tài liệu về: cơ học lý thuyết (momen lực, điều kiện cân bằng), lý thuyết điều khiển tự động (bộ điều khiển PID, ổn định hệ thống), kỹ thuật cảm biến (nguyên lý loadcell, xử lý tín hiệu), và lập trình hệ thống nhúng (kiến trúc real-time, xử lý ngắt).

Tổng hợp kiến thức từ các nghiên cứu trước đó về điều khiển động cơ bước, đặc biệt là các vấn đề về hiệu năng thời gian thực khi kết hợp nhiều tác vụ (đọc cảm biến, điều khiển động cơ, giao tiếp Serial).

\subsection{Phương pháp mô hình hóa và thiết kế}

Xây dựng mô hình toán học của hệ thống cân bằng dựa trên nguyên lý momen lực. Từ đó xác định mối quan hệ giữa độ lệch tải trọng và vị trí đối trọng cần thiết để cân bằng.

Thiết kế cơ khí sử dụng phương pháp thiết kế mô-đun, cho phép dễ dàng điều chỉnh và thay thế các thành phần. Thiết kế mạch điện theo sơ đồ khối, xác định rõ chức năng và giao tiếp của từng module.

Thiết kế phần mềm theo kiến trúc phân tầng: tầng phần cứng (Hardware Abstraction Layer), tầng điều khiển (Control Layer), và tầng ứng dụng (Application Layer).

\subsection{Phương pháp thực nghiệm}

Chế tạo mô hình thực tế dựa trên thiết kế đã xây dựng. Tiến hành hiệu chuẩn (calibration) các cảm biến loadcell để đảm bảo độ chính xác đo lường.

Thực hiện các bài test với nhiều kịch bản tải trọng khác nhau: tải tĩnh (đặt vật nặng cố định), tải động (di chuyển vật nặng trong quá trình hoạt động), và tải biến thiên (thay đổi khối lượng tải).

Thu thập dữ liệu thông qua Serial Monitor, bao gồm: giá trị đọc từ loadcell, sai số (Input), tín hiệu điều khiển (Output), và tốc độ động cơ. Phân tích dữ liệu để đánh giá hiệu quả của thuật toán điều khiển.

\subsection{Phương pháp phân tích và đánh giá}

So sánh kết quả thực nghiệm với các chỉ tiêu thiết kế ban đầu. Phân tích nguyên nhân của các sai lệch (nếu có) và đề xuất giải pháp khắc phục.

Đánh giá định lượng các thông số: thời gian đáp ứng (từ khi có tải lệch đến khi đạt cân bằng), độ chính xác cân bằng (sai số còn lại sau khi ổn định), và phạm vi hoạt động (độ lệch tối đa có thể bù đắp).

Phân tích các yếu tố ảnh hưởng đến hiệu năng hệ thống, bao gồm: tham số PID, tốc độ lấy mẫu, độ phân giải microstep, và các vấn đề về lập trình thời gian thực.

\section{Ý nghĩa khoa học và thực tiễn}

\subsection{Ý nghĩa khoa học}

Khóa luận đóng góp vào việc nghiên cứu ứng dụng lý thuyết điều khiển tự động trong bài toán cân bằng trọng tâm cho robot di động. Các kết quả nghiên cứu về ảnh hưởng của kiến trúc phần mềm (blocking vs non-blocking) đến hiệu năng điều khiển động cơ bước có giá trị tham khảo cho các nghiên cứu liên quan.

Việc phân tích chi tiết các vấn đề thời gian thực trong hệ thống nhúng -- từ độ trễ của giao tiếp Serial đến ảnh hưởng của tần số lấy mẫu -- cung cấp cơ sở lý thuyết và thực nghiệm cho việc thiết kế các hệ thống điều khiển tương tự.

\subsection{Ý nghĩa thực tiễn}

Sản phẩm của khóa luận là một khung đế robot có khả năng tự cân bằng, có thể được tích hợp vào các robot di động thực tế để cải thiện độ ổn định khi vận hành.

Các kinh nghiệm thiết kế và chế tạo (lựa chọn linh kiện, giải quyết các vấn đề kỹ thuật, tinh chỉnh hệ thống) được tài liệu hóa trong khóa luận, có thể làm tài liệu tham khảo cho các dự án tương tự.

Mã nguồn chương trình điều khiển được cung cấp đầy đủ trong phụ lục, có thể được sử dụng lại hoặc phát triển thêm cho các ứng dụng khác.

\section{Bố cục khóa luận}

Khóa luận được trình bày trong 5 chương với nội dung như sau:

\textbf{Chương 1: Tổng quan} -- Trình bày bối cảnh và lý do chọn đề tài, xác định mục tiêu nghiên cứu, đối tượng và phạm vi nghiên cứu, các phương pháp nghiên cứu được sử dụng, cũng như ý nghĩa khoa học và thực tiễn của đề tài.

\textbf{Chương 2: Cơ sở lý thuyết} -- Trình bày các kiến thức nền tảng về nguyên lý cân bằng trọng tâm và momen lực, cảm biến lực Loadcell và module HX711, động cơ bước và kỹ thuật vi bước, vi điều khiển Arduino, thuật toán điều khiển PID, và các vấn đề lập trình thời gian thực cho hệ thống nhúng.

\textbf{Chương 3: Thiết kế hệ thống} -- Mô tả chi tiết quá trình thiết kế gồm: phân tích yêu cầu, thiết kế cơ khí (khung, cơ cấu vitme-thanh trượt, bố trí loadcell), thiết kế mạch điện (sơ đồ khối, kết nối phần cứng), và thiết kế phần mềm (cấu trúc chương trình, quy trình Homing, logic điều khiển PID với Deadzone và Hysteresis).

\textbf{Chương 4: Thực nghiệm và đánh giá} -- Trình bày môi trường và điều kiện thử nghiệm, quá trình tinh chỉnh tham số PID, kết quả thực nghiệm với các kịch bản tải trọng khác nhau, phân tích hiệu năng hệ thống, và đánh giá so với mục tiêu đề ra.

\textbf{Chương 5: Kết luận và hướng phát triển} -- Tổng kết các kết quả đạt được của khóa luận, nêu rõ các hạn chế còn tồn tại, và đề xuất các hướng phát triển tiếp theo bao gồm: tăng tốc độ phản hồi, mở rộng cân bằng hai trục, và tích hợp điều khiển vị trí/tốc độ.

%======================================================================
% CHƯƠNG 2: CƠ SỞ LÝ THUYẾT
%======================================================================
\chapter{Cơ sở lý thuyết}

Chương này trình bày các kiến thức nền tảng cần thiết cho việc thiết kế và xây dựng hệ thống cân bằng trọng tâm tự động. Các nội dung được trình bày bao gồm: lý thuyết cơ học về cân bằng và momen lực, nguyên lý hoạt động của cảm biến lực và module chuyển đổi tín hiệu, đặc tính của động cơ bước và kỹ thuật điều khiển vi bước, nền tảng vi điều khiển Arduino, thuật toán điều khiển PID, và đặc biệt là các vấn đề về lập trình thời gian thực trong hệ thống nhúng.

%======================================================================
% PHẦN BỔ SUNG CHO CHƯƠNG 2: SO SÁNH CÁC PHƯƠNG PHÁP CÂN BẰNG
% Chèn vào đầu Chương 2, sau phần giới thiệu chương
% hoặc sau phần "Nguyên lý cân bằng trọng tâm"
%======================================================================

\section{So sánh các phương pháp cân bằng robot}

Trong lĩnh vực robot di động, có nhiều phương pháp khác nhau để duy trì sự cân bằng và ổn định. Mỗi phương pháp có nguyên lý hoạt động, ưu điểm và hạn chế riêng, phù hợp với các ứng dụng cụ thể. Phần này trình bày và so sánh bốn phương pháp cân bằng phổ biến nhất.

\subsection{Các phương pháp cân bằng chính}

\textbf{Phương pháp 1 - Điều khiển bánh xe (Wheel-based Balancing):} Đây là phương pháp phổ biến nhất, được sử dụng trong robot tự cân bằng hai bánh như Segway. Nguyên lý hoạt động dựa trên việc di chuyển bánh xe theo hướng robot đang nghiêng để ``đuổi theo'' trọng tâm, tương tự như cách con người giữ thăng bằng khi đứng. Cảm biến IMU (gyroscope và accelerometer) đo góc nghiêng, sau đó bộ điều khiển tính toán tốc độ bánh xe cần thiết để giữ thăng bằng.

\textbf{Phương pháp 2 - Bánh đà/Con quay hồi chuyển (Reaction Wheel/CMG):} Phương pháp này sử dụng momen động lượng của một hoặc nhiều bánh đà quay tốc độ cao. Khi cần tạo momen cân bằng, động cơ tăng hoặc giảm tốc độ bánh đà, theo định luật bảo toàn momen động lượng, một momen phản lực sẽ tác động lên thân robot. Control Moment Gyroscope (CMG) là biến thể sử dụng hiệu ứng tiến động của con quay hồi chuyển.

\textbf{Phương pháp 3 - Khối lượng di động (Moving Mass):} Nguyên lý hoạt động dựa trên việc di chuyển một khối lượng đối trọng để thay đổi vị trí trọng tâm của hệ thống. Khi phát hiện độ lệch, khối đối trọng được di chuyển về phía đối diện để bù đắp momen lực gây mất cân bằng. Đây chính là phương pháp được áp dụng trong đề tài này.

\textbf{Phương pháp 4 - Mở rộng đa giác đỡ (Support Polygon Expansion):} Phương pháp này tăng độ ổn định tĩnh bằng cách mở rộng diện tích tiếp xúc với mặt đất. Các robot có thể sử dụng chân chống, bánh xe phụ, hoặc thay đổi tư thế để mở rộng đa giác đỡ. Tuy nhiên, phương pháp này làm giảm tính linh hoạt của robot.

\subsection{Bảng so sánh tổng hợp}

Bảng 2.1 trình bày so sánh chi tiết bốn phương pháp cân bằng theo các tiêu chí quan trọng.

\begin{table}[H]{So sánh các phương pháp cân bằng robot}
\centering
\small
\begin{tabular}{|p{2.8cm}|p{2.8cm}|p{2.8cm}|p{2.8cm}|p{2.8cm}|}
\hline
\textbf{Tiêu chí} & \textbf{Điều khiển bánh xe} & \textbf{Bánh đà/CMG} & \textbf{Khối lượng di động} & \textbf{Mở rộng đa giác đỡ} \\
\hline
\textbf{Nguyên lý} & Di chuyển bánh xe theo hướng nghiêng & Thay đổi tốc độ bánh đà tạo momen phản lực & Di chuyển đối trọng thay đổi trọng tâm & Tăng diện tích tiếp xúc mặt đất \\
\hline
\textbf{Cảm biến chính} & IMU (gyro + accel) & IMU (gyro + accel) & Loadcell hoặc IMU & Cảm biến tiếp xúc, IMU \\
\hline
\textbf{Cơ cấu chấp hành} & Động cơ DC/BLDC cho bánh xe & Động cơ BLDC tốc độ cao & Động cơ bước + vitme/đai & Động cơ servo, xi-lanh \\
\hline
\textbf{Thời gian đáp ứng} & Rất nhanh (ms) & Nhanh (ms) & Trung bình (100ms-1s) & Chậm (giây) \\
\hline
\textbf{Khả năng cân bằng tĩnh} & Không (cần di chuyển liên tục) & Có (giới hạn bởi saturation) & Có (trong phạm vi hành trình) & Có (ổn định nhất) \\
\hline
\textbf{Tiêu hao năng lượng} & Cao khi đứng yên & Cao (bánh đà quay liên tục) & Thấp khi đã cân bằng & Rất thấp \\
\hline
\textbf{Độ phức tạp điều khiển} & Cao (hệ bất ổn định) & Rất cao & Trung bình & Thấp \\
\hline
\textbf{Độ phức tạp cơ khí} & Thấp-Trung bình & Cao & Trung bình & Thấp-Cao \\
\hline
\textbf{Khả năng chịu tải thay đổi} & Hạn chế & Hạn chế & Tốt (thiết kế phù hợp) & Tốt \\
\hline
\textbf{Tính linh hoạt di chuyển} & Cao & Cao & Cao & Thấp \\
\hline
\textbf{Ứng dụng tiêu biểu} & Segway, robot giao hàng & Vệ tinh, xe đạp tự lái & Robot mang tải, cần cẩu & Robot công nghiệp, xe nâng \\
\hline
\textbf{Chi phí triển khai} & Trung bình & Cao & Thấp-Trung bình & Thấp \\
\hline
\end{tabular}
\end{table}

\subsection{Phân tích ưu nhược điểm chi tiết}

\textbf{Điều khiển bánh xe:}
Ưu điểm bao gồm khả năng đáp ứng rất nhanh, cấu trúc cơ khí đơn giản, và robot có thể di chuyển linh hoạt. Nhược điểm chính là không thể cân bằng tĩnh (phải di chuyển liên tục để giữ thăng bằng), tiêu hao năng lượng cao khi đứng yên, và yêu cầu mặt sàn phẳng để hoạt động hiệu quả. Phương pháp này phù hợp với các ứng dụng di chuyển liên tục như robot giao hàng, xe cân bằng cá nhân.

\textbf{Bánh đà/CMG:}
Ưu điểm là có thể cân bằng mà không cần di chuyển bánh xe, đáp ứng nhanh, và hoạt động được trên nhiều loại địa hình. Nhược điểm bao gồm tiêu hao năng lượng liên tục (bánh đà phải quay), vấn đề bão hòa momen động lượng (saturation) khi nhiễu kéo dài, độ phức tạp cơ khí cao, và tiếng ồn từ bánh đà tốc độ cao. Phương pháp này phù hợp với vệ tinh, tàu vũ trụ, và các robot cần cân bằng chính xác trong thời gian ngắn.

\textbf{Khối lượng di động (Phương pháp được chọn):}
Ưu điểm là tiêu hao năng lượng thấp sau khi đã cân bằng (động cơ dừng), cấu trúc đơn giản với linh kiện phổ biến, có thể đo trực tiếp phân bố tải bằng loadcell, và phù hợp với ứng dụng cân bằng tĩnh hoặc bán tĩnh. Nhược điểm bao gồm thời gian đáp ứng chậm hơn (phụ thuộc vào tốc độ vitme), giới hạn bởi hành trình di chuyển của đối trọng, và khả năng bù đắp phụ thuộc vào khối lượng đối trọng. Phương pháp này phù hợp với robot mang tải có trọng tâm thay đổi chậm, khung đế cân bằng cho cánh tay robot.

\textbf{Mở rộng đa giác đỡ:}
Ưu điểm là độ ổn định cao nhất, không cần điều khiển phức tạp, và tiêu hao năng lượng rất thấp. Nhược điểm là làm giảm tính linh hoạt và khả năng di chuyển, tăng kích thước và khối lượng robot, và thời gian chuyển đổi trạng thái chậm. Phương pháp này phù hợp với robot công nghiệp cố định, xe nâng hàng, và các ứng dụng ưu tiên độ ổn định tuyệt đối.

\subsection{Lý do lựa chọn phương pháp khối lượng di động}

Đề tài này lựa chọn phương pháp khối lượng di động dựa trên các lý do sau:

Thứ nhất, về đặc điểm ứng dụng: Khung đế robot được thiết kế để cân bằng khi tải thay đổi (ví dụ: cánh tay robot gắp vật), không yêu cầu thời gian đáp ứng cực nhanh như robot tự cân bằng động.

Thứ hai, về hiệu quả năng lượng: Sau khi đạt vị trí cân bằng, động cơ bước có thể dừng hoàn toàn (giữ vị trí bằng momen từ tính), tiết kiệm năng lượng đáng kể so với phương pháp bánh đà.

Thứ ba, về khả năng đo lường: Việc sử dụng loadcell cho phép đo trực tiếp chênh lệch trọng lượng giữa hai bên, cung cấp phản hồi chính xác về trạng thái cân bằng mà không cần tính toán phức tạp từ góc nghiêng.

Thứ tư, về tính khả thi: Các linh kiện cần thiết (động cơ bước, vitme, loadcell, Arduino) đều phổ biến và có giá thành hợp lý tại Việt Nam, phù hợp với điều kiện nghiên cứu và triển khai.

Thứ năm, về độ phức tạp: So với phương pháp bánh đà hoặc CMG, phương pháp khối lượng di động có độ phức tạp cơ khí và điều khiển thấp hơn, thuận lợi cho việc nghiên cứu và phát triển trong khuôn khổ đồ án tốt nghiệp.

\section{Lý thuyết cân bằng trọng tâm và momen lực}

\subsection{Khái niệm trọng tâm}

Trọng tâm (Center of Gravity - CoG) của một vật thể hoặc hệ vật là điểm mà tại đó toàn bộ trọng lượng của hệ có thể được coi như tập trung. Đối với một hệ thống gồm $n$ vật thể rời rạc, vị trí trọng tâm theo trục $x$ được xác định bởi công thức:

\begin{equation}
x_G = \frac{\sum_{i=1}^{n} m_i \cdot x_i}{\sum_{i=1}^{n} m_i} = \frac{\sum_{i=1}^{n} m_i \cdot x_i}{M}
\label{eq:center_of_gravity}
\end{equation}

trong đó $x_G$ là tọa độ trọng tâm của hệ, $m_i$ là khối lượng của vật thể thứ $i$, $x_i$ là tọa độ của vật thể thứ $i$ theo trục $x$, và $M = \sum m_i$ là tổng khối lượng của hệ.

Công thức tương tự được áp dụng cho các trục $y$ và $z$ trong không gian ba chiều. Trong phạm vi khóa luận này, bài toán được đơn giản hóa thành cân bằng theo một trục (trái-phải), tương ứng với việc xét trọng tâm trên trục $x$.

\subsection{Momen lực và điều kiện cân bằng tĩnh}

Momen lực (Torque) là đại lượng vật lý đặc trưng cho tác dụng làm quay của một lực đối với một trục quay. Độ lớn của momen lực được tính theo công thức:

\begin{equation}
M = F \times d
\label{eq:torque}
\end{equation}

trong đó $M$ là momen lực (đơn vị N.m hoặc N.mm), $F$ là lực tác dụng (N), và $d$ là cánh tay đòn -- khoảng cách vuông góc từ đường tác dụng của lực đến trục quay (m hoặc mm).

Quy ước dấu: Momen làm vật quay theo chiều kim đồng hồ thường được quy ước là âm, ngược chiều kim đồng hồ là dương (hoặc ngược lại, tùy theo hệ quy chiếu được chọn).

Điều kiện cân bằng tĩnh của một vật rắn yêu cầu tổng các momen lực tác dụng lên vật đối với một trục quay bất kỳ phải bằng không:

\begin{equation}
\sum M = 0
\label{eq:equilibrium}
\end{equation}

Điều kiện này có nghĩa là tổng các momen theo chiều dương phải cân bằng với tổng các momen theo chiều âm.

\subsection{Áp dụng nguyên lý momen vào bài toán cân bằng khung robot}

Xét mô hình khung đế robot như một thanh cứng được đỡ tại điểm tựa ở giữa (tâm khung). Khi có tải trọng đặt lệch về một phía, momen do tải gây ra sẽ làm khung mất cân bằng. Để khôi phục cân bằng, cần di chuyển một khối đối trọng về phía đối diện sao cho momen do đối trọng tạo ra bù đắp momen do tải.

Điều kiện cân bằng được viết như sau:

\begin{equation}
m_{slider} \times d_{slider} = m_{load} \times d_{load}
\label{eq:balance_condition}
\end{equation}

trong đó $m_{slider}$ là khối lượng của khối đối trọng (kg hoặc g), $d_{slider}$ là khoảng cách từ đối trọng đến tâm khung (mm), $m_{load}$ là độ chênh lệch khối lượng tải giữa hai bên (kg hoặc g), và $d_{load}$ là khoảng cách từ điểm đặt tải đến tâm khung (mm).

Từ phương trình \eqref{eq:balance_condition}, có thể suy ra vị trí cần thiết của đối trọng:

\begin{equation}
d_{slider} = \frac{m_{load} \times d_{load}}{m_{slider}}
\label{eq:slider_position}
\end{equation}

Phương trình này cho thấy một hạn chế quan trọng: với khối lượng đối trọng cố định $m_{slider}$ và hành trình giới hạn $d_{slider,max}$, độ lệch tải tối đa có thể bù đắp là:

\begin{equation}
m_{load,max} = \frac{m_{slider} \times d_{slider,max}}{d_{load}}
\label{eq:max_load}
\end{equation}

Ví dụ cụ thể từ hệ thống được thiết kế: với $m_{slider} = 200$g, $d_{slider,max} = 120$mm, và $d_{load} = 175$mm (một nửa chiều rộng khung 35cm), độ lệch tải tối đa có thể bù đắp là:

\begin{equation}
m_{load,max} = \frac{200 \times 120}{175} \approx 137 \text{ g}
\end{equation}

Kết quả này cho thấy để tăng khả năng cân bằng, có thể: (1) tăng khối lượng đối trọng, (2) tăng hành trình di chuyển, hoặc (3) bố trí tải gần tâm hơn.

\section{Cảm biến lực Loadcell và module HX711}

\subsection{Cấu tạo và nguyên lý hoạt động của Loadcell}

Loadcell là cảm biến chuyển đổi lực cơ học thành tín hiệu điện, hoạt động dựa trên hiệu ứng điện trở biến dạng (Piezoresistive effect). Cấu tạo cơ bản của loadcell gồm:

\textbf{Thân đàn hồi (Elastic element):} Thường làm từ thép hợp kim hoặc nhôm, được gia công với hình dạng đặc biệt để biến dạng theo hướng xác định khi chịu lực.

\textbf{Điện trở biến dạng (Strain gauge):} Là các dải điện trở mỏng được dán trực tiếp lên bề mặt thân đàn hồi. Khi thân đàn hồi biến dạng, điện trở của strain gauge thay đổi theo quan hệ:

\begin{equation}
\frac{\Delta R}{R} = GF \times \varepsilon
\label{eq:strain_gauge}
\end{equation}

trong đó $\Delta R/R$ là tỷ lệ thay đổi điện trở, $GF$ là hệ số gauge (Gauge Factor, thường từ 2 đến 4 cho strain gauge kim loại), và $\varepsilon$ là biến dạng tương đối của vật liệu.

\textbf{Cầu Wheatstone:} Bốn strain gauge được mắc theo cấu hình cầu Wheatstone để chuyển đổi sự thay đổi điện trở thành sự thay đổi điện áp. Cấu hình cầu đầy đủ (Full-bridge) cho độ nhạy cao nhất và khả năng bù nhiệt tốt.

Điện áp đầu ra của cầu Wheatstone:

\begin{equation}
V_{out} = V_{exc} \times \frac{\Delta R}{R}
\label{eq:wheatstone}
\end{equation}

trong đó $V_{exc}$ là điện áp kích thích (thường 5V hoặc 10V).

\subsection{Loadcell 3 dây và cách ghép thành cầu đầy đủ}

Trong dự án này, loadcell 3 dây (half-bridge) được sử dụng. Loại loadcell này chỉ chứa hai strain gauge, cần ghép hai loadcell lại để tạo thành cầu Wheatstone đầy đủ.

Cách đấu nối hai loadcell 3 dây thành một cầu cho module HX711:
\begin{itemize}
    \item Loadcell 1: Dây trắng vào E-, dây đen vào E+
    \item Loadcell 2: Dây trắng vào A-, dây đen vào E+
    \item Kết nối chung: Nối hai dây đỏ của cả hai loadcell lại với nhau và đưa vào chân A+
\end{itemize}

Với cách ghép này, hệ thống sử dụng 4 loadcell 50kg (2 cặp), tạo thành 2 cụm cảm biến độc lập cho bên trái và bên phải, mỗi cụm có khả năng chịu tải tổng cộng 100kg.

\subsection{Module HX711 và giao thức truyền thông}

HX711 là IC chuyển đổi tương tự sang số (ADC) 24-bit được thiết kế chuyên dụng cho các ứng dụng cân điện tử. Các đặc tính kỹ thuật chính:

\begin{itemize}
    \item Độ phân giải: 24-bit (tương đương khoảng 16.7 triệu mức lượng tử hóa)
    \item Tốc độ lấy mẫu: 10 SPS (Samples Per Second) hoặc 80 SPS, tùy thuộc vào mức logic của chân RATE
    \item Bộ khuếch đại tích hợp: Độ lợi (Gain) có thể chọn 32, 64, hoặc 128
    \item Giao tiếp: Giao thức nối tiếp đồng bộ 2 dây (DOUT và SCK)
    \item Nguồn cấp: 2.6V đến 5.5V
\end{itemize}

Giao thức truyền thông của HX711 hoạt động như sau: Vi điều khiển tạo xung clock trên chân SCK và đọc dữ liệu từ chân DOUT. Mỗi lần đọc, HX711 truyền 24 bit dữ liệu ADC, sau đó 1-3 xung clock bổ sung để chọn kênh và độ lợi cho lần đọc tiếp theo.

\subsection{Thư viện HX711\_ADC và cơ chế Non-blocking}

Một trong những quyết định kỹ thuật quan trọng của dự án là sử dụng thư viện \texttt{HX711\_ADC} của tác giả Olav Kallhovd thay vì thư viện \texttt{HX711} chuẩn (của Bogde). Sự khác biệt cốt lõi nằm ở cơ chế đọc dữ liệu:

\textbf{Thư viện HX711 chuẩn (Blocking):}
\begin{itemize}
    \item Hàm chính: \texttt{scale.get\_units(n)}
    \item Cơ chế: Khi gọi hàm, vi điều khiển \textbf{dừng lại và chờ} cho đến khi HX711 hoàn thành chuyển đổi
    \item Thời gian chờ: Ở tốc độ 10Hz, mỗi lần đọc mất 100ms. Nếu lấy trung bình 5 mẫu (\texttt{get\_units(5)}), thời gian chờ lên đến 500ms
    \item Hậu quả: Trong thời gian chờ, các lệnh điều khiển động cơ không được thực thi, gây hiện tượng động cơ chạy giật cục hoặc dừng hẳn
\end{itemize}

\textbf{Thư viện HX711\_ADC (Non-blocking):}
\begin{itemize}
    \item Hàm chính: \texttt{LoadCell.update()} và \texttt{LoadCell.getData()}
    \item Cơ chế: Hàm \texttt{update()} chỉ kiểm tra xem có dữ liệu mới hay không. Nếu chưa có, hàm trả về ngay lập tức (tốn vài micro-giây). Nếu có dữ liệu mới, hàm đọc và lưu vào biến nội bộ
    \item Hàm \texttt{getData()} lấy giá trị từ biến nội bộ ra một cách tức thì, không cần chờ đợi
    \item Lợi ích: Vi điều khiển có thể thực hiện các tác vụ khác (như điều khiển động cơ) trong khi chờ dữ liệu từ cảm biến
\end{itemize}

Sự khác biệt này có ý nghĩa quyết định đối với hiệu năng hệ thống. Với kiến trúc Non-blocking, hàm \texttt{stepper.runSpeed()} có thể được gọi liên tục trong vòng lặp chính mà không bị gián đoạn bởi việc đọc cảm biến, đảm bảo động cơ bước hoạt động mượt mà ở tốc độ cao.

\section{Động cơ bước và driver TB6600}

\subsection{Nguyên lý hoạt động của động cơ bước}

Động cơ bước (Stepper Motor) là loại động cơ điện chuyển đổi các xung điện rời rạc thành chuyển động quay theo từng bước góc cố định. Khác với động cơ DC thông thường (có tốc độ phụ thuộc vào điện áp), vị trí và tốc độ của động cơ bước được xác định hoàn toàn bởi số lượng và tần số của các xung điều khiển.

Động cơ bước lai (Hybrid Stepper Motor) -- loại phổ biến nhất trong các ứng dụng công nghiệp và được sử dụng trong dự án này (Nema 17) -- kết hợp ưu điểm của động cơ bước nam châm vĩnh cửu và động cơ bước biến từ trở. Cấu tạo gồm:

\textbf{Stator:} Chứa các cuộn dây được quấn theo cặp (Phase A và Phase B cho động cơ lưỡng cực). Khi có dòng điện chạy qua, các cuộn dây tạo ra từ trường.

\textbf{Rotor:} Gồm lõi nam châm vĩnh cửu được bọc bởi hai đĩa răng lệch pha nhau. Kết hợp với răng trên stator, cấu trúc này cho phép góc bước nhỏ (thường 1.8°, tương đương 200 bước/vòng).

Nguyên lý hoạt động: Khi dòng điện trong các cuộn dây thay đổi theo trình tự xác định, từ trường stator quay theo, kéo rotor quay theo từng bước. Mỗi bước tương ứng với một góc cố định:

\begin{equation}
\theta_{step} = \frac{360°}{N_{steps}}
\label{eq:step_angle}
\end{equation}

trong đó $N_{steps}$ là số bước trên một vòng quay (200 cho động cơ 1.8°).

\subsection{Chế độ vi bước (Microstepping) và ảnh hưởng đến hiệu năng}

Vi bước là kỹ thuật điều khiển dòng điện trong các cuộn dây theo dạng sóng sin/cosin thay vì dạng bước vuông. Điều này cho phép chia nhỏ mỗi bước đầy đủ thành nhiều bước nhỏ hơn.

Số bước trên mỗi vòng quay khi sử dụng vi bước:

\begin{equation}
N_{micro} = N_{full} \times k
\label{eq:microstep}
\end{equation}

trong đó $N_{full} = 200$ bước/vòng (cho động cơ 1.8°) và $k$ là hệ số vi bước (1, 2, 4, 8, 16, 32...).

Với chế độ 1/16 microstep được sử dụng trong dự án:
\begin{equation}
N_{micro} = 200 \times 16 = 3200 \text{ bước/vòng}
\end{equation}

\textbf{Ưu điểm của vi bước:}
\begin{itemize}
    \item Chuyển động mượt mà hơn, giảm rung động và tiếng ồn
    \item Độ phân giải vị trí cao hơn
    \item Giảm hiện tượng cộng hưởng ở một số dải tốc độ
\end{itemize}

\textbf{Nhược điểm và thách thức:}
\begin{itemize}
    \item Yêu cầu tần số xung điều khiển cao hơn để đạt cùng tốc độ quay
    \item Tăng tải xử lý cho vi điều khiển
    \item Momen xoắn giảm nhẹ so với chế độ full-step
\end{itemize}

\textbf{Phân tích ràng buộc thời gian thực:}

Xét yêu cầu tốc độ 300 RPM (5 vòng/giây):
\begin{itemize}
    \item Ở chế độ Full-step: Tần số xung = $200 \times 5 = 1000$ Hz. Khoảng cách giữa các bước = 1000 $\mu$s
    \item Ở chế độ 1/16 Microstep: Tần số xung = $3200 \times 5 = 16000$ Hz. Khoảng cách giữa các bước = 62.5 $\mu$s
\end{itemize}

Con số 62.5 $\mu$s là ``ngân sách thời gian'' (time budget) tối đa mà vi điều khiển có để hoàn thành mọi tác vụ giữa hai lần tạo xung. Nếu bất kỳ tác vụ nào (đọc cảm biến, tính toán PID, giao tiếp Serial) chiếm thời gian lớn hơn ngưỡng này, hệ thống sẽ vi phạm ràng buộc thời gian thực và động cơ sẽ mất bước.

\subsection{Driver TB6600 và cấu hình điều khiển}

TB6600 là driver công suất cao cho động cơ bước, được thiết kế để điều khiển các động cơ Nema 17 và Nema 23. Thông số kỹ thuật:

\begin{itemize}
    \item Điện áp làm việc: 9-42V DC
    \item Dòng điện tối đa: 4A/pha (có thể điều chỉnh bằng DIP switch)
    \item Hỗ trợ vi bước: Full, 1/2, 1/4, 1/8, 1/16, 1/32
    \item Tín hiệu điều khiển: PUL+ (xung bước), DIR+ (chiều quay), ENA+ (kích hoạt)
    \item Cách ly quang học giữa tín hiệu điều khiển và mạch công suất
\end{itemize}

Giao thức điều khiển đơn giản: Mỗi xung trên chân PUL làm động cơ quay một vi bước. Mức logic trên chân DIR quyết định chiều quay (HIGH = thuận, LOW = nghịch). Chân ENA thường được bỏ trống hoặc nối với mức logic phù hợp để luôn kích hoạt driver.

\subsection{Thư viện AccelStepper và cơ chế Polling}

Thư viện AccelStepper của Mike McCauley là thư viện phổ biến nhất cho điều khiển động cơ bước trên Arduino. Thư viện hoạt động theo cơ chế \textbf{Polling} (hỏi vòng), không phải Interrupt-driven (ngắt).

Hàm cốt lõi \texttt{runSpeed()} hoạt động như sau (mã giả):

\begin{lstlisting}[style=arduino]
boolean AccelStepper::runSpeed() {
    unsigned long time = micros();
    if (time >= _nextStepTime) {
        step(_direction);  // Thuc hien buoc
        _nextStepTime = time + _stepInterval;
        return true;
    }
    return false;  // Chua den luc, khong lam gi
}
\end{lstlisting}

Thiết kế này đặt ra yêu cầu quan trọng: \textbf{Hàm \texttt{runSpeed()} phải được gọi với tần số cao hơn nhiều so với tần số bước của động cơ}. Nếu động cơ cần bước mỗi 62.5 $\mu$s (ở 1/16 microstep, 300 RPM), thì \texttt{runSpeed()} cần được gọi ít nhất mỗi 30 $\mu$s để đảm bảo độ chính xác thời gian.

Thư viện cũng cung cấp các hàm khác như \texttt{run()} (có gia tốc), \texttt{runToPosition()} và \texttt{runToNewPosition()} (chạy đến vị trí đích). Tuy nhiên, hai hàm sau là \textbf{blocking} -- chúng chứa vòng lặp nội bộ và không trả về cho đến khi động cơ đạt vị trí đích. Trong dự án này, \texttt{runSpeed()} được sử dụng trong vòng lặp chính để đảm bảo tính non-blocking.

\section{Vi điều khiển Arduino}

\subsection{Kiến trúc phần cứng ATmega328P}

Arduino Uno/Nano sử dụng vi điều khiển ATmega328P của Atmel (nay thuộc Microchip). Đây là vi điều khiển 8-bit kiến trúc AVR với các thông số:

\begin{itemize}
    \item Tần số xung nhịp: 16 MHz (chu kỳ lệnh 62.5 ns)
    \item Bộ nhớ Flash (chương trình): 32 KB
    \item Bộ nhớ SRAM (dữ liệu): 2 KB
    \item Bộ nhớ EEPROM: 1 KB
    \item Chân I/O số: 14 (trong đó 6 chân hỗ trợ PWM)
    \item Chân đầu vào analog: 6 (ADC 10-bit)
    \item Giao tiếp: UART, SPI, I2C
    \item Timer: 2 timer 8-bit, 1 timer 16-bit
\end{itemize}

Với tần số 16 MHz, vi điều khiển có thể thực thi khoảng 16 triệu lệnh đơn giản mỗi giây. Tuy nhiên, các thao tác phức tạp như phép tính dấu phẩy động, giao tiếp Serial, hay đọc ADC tiêu tốn nhiều chu kỳ xung nhịp hơn.

\subsection{Mô hình lập trình Arduino}

Arduino sử dụng mô hình lập trình đơn giản với hai hàm chính:

\texttt{setup()}: Được gọi một lần khi khởi động, dùng để khởi tạo các thành phần phần cứng và phần mềm.

\texttt{loop()}: Được gọi lặp đi lặp lại vô hạn sau khi \texttt{setup()} hoàn thành. Đây là nơi chứa logic chính của chương trình.

Mô hình này tương đương với kiến trúc \textbf{Superloop} trong lập trình hệ thống nhúng -- một vòng lặp vô hạn thực thi tuần tự các tác vụ. Ưu điểm là đơn giản, dễ hiểu. Nhược điểm là khó đảm bảo thời gian đáp ứng cho các tác vụ quan trọng nếu có tác vụ blocking trong vòng lặp.

\subsection{Vấn đề Blocking I/O trong giao tiếp Serial}

Giao tiếp Serial (UART) là nguồn gây blocking phổ biến nhất trong các chương trình Arduino. Phân tích chi tiết cơ chế hoạt động:

\textbf{Bộ đệm truyền (TX Buffer):}

Arduino sử dụng bộ đệm vòng (ring buffer) với kích thước mặc định 64 byte để chứa dữ liệu chờ gửi. Khi gọi \texttt{Serial.print()}, dữ liệu được sao chép vào buffer. Nếu buffer còn trống, hàm trả về ngay lập tức (non-blocking). Một trình phục vụ ngắt (ISR) chạy ngầm sẽ lấy từng byte từ buffer và gửi ra chân TX.

\textbf{Hiện tượng Buffer Overflow:}

Vấn đề xảy ra khi tốc độ ghi dữ liệu vào buffer cao hơn tốc độ gửi ra ngoài. Tốc độ gửi bị giới hạn bởi Baud Rate. Ở 9600 baud, thời gian gửi 1 byte:

\begin{equation}
t_{byte} = \frac{10 \text{ bits}}{9600 \text{ bps}} \approx 1.04 \text{ ms}
\label{eq:uart_time}
\end{equation}

(10 bits = 1 start bit + 8 data bits + 1 stop bit)

Khi buffer đầy (64 byte), hàm \texttt{Serial.write()} chuyển sang chế độ blocking -- chờ đợi cho đến khi có chỗ trống trong buffer. Trong thời gian chờ, CPU không thể thực hiện các tác vụ khác.

\textbf{Tính toán thiệt hại thời gian:}

Giả sử chương trình in dòng lệnh 25 ký tự mỗi vòng lặp, và buffer đã đầy. Thời gian blocking:

\begin{equation}
T_{delay} \approx 25 \times 1.04 \text{ ms} = 26 \text{ ms}
\end{equation}

Trong 26 ms này:
\begin{itemize}
    \item Hàm \texttt{runSpeed()} không được gọi
    \item Động cơ (yêu cầu xung mỗi 62.5 $\mu$s) bỏ lỡ: $\frac{26000}{62.5} \approx 416$ xung
    \item Tốc độ thực tế giảm từ 16000 bước/s xuống còn khoảng 38 bước/s
\end{itemize}

Đây là lý do tại sao việc in Serial không kiểm soát có thể làm động cơ bước ``chậm như bị mắc kẹt'' -- hiện tượng được ghi nhận trong quá trình phát triển hệ thống.

\section{Thuật toán điều khiển PID}

\subsection{Mô hình toán học của bộ điều khiển PID}

PID (Proportional-Integral-Derivative) là thuật toán điều khiển vòng kín phổ biến nhất trong công nghiệp. Bộ điều khiển PID tính toán tín hiệu điều khiển $u(t)$ dựa trên sai số $e(t)$ giữa giá trị đặt (Setpoint) và giá trị thực tế (Process Variable):

\begin{equation}
u(t) = K_p \cdot e(t) + K_i \cdot \int_0^t e(\tau) \, d\tau + K_d \cdot \frac{de(t)}{dt}
\label{eq:pid_continuous}
\end{equation}

trong đó:
\begin{itemize}
    \item $u(t)$: Tín hiệu điều khiển (output)
    \item $e(t) = SP - PV$: Sai số (error)
    \item $K_p$: Hệ số khuếch đại tỷ lệ (Proportional gain)
    \item $K_i$: Hệ số khuếch đại tích phân (Integral gain)
    \item $K_d$: Hệ số khuếch đại vi phân (Derivative gain)
\end{itemize}

\subsection{Vai trò của từng thành phần}

\textbf{Thành phần tỷ lệ (P):}

Tạo ra tín hiệu điều khiển tỷ lệ thuận với sai số hiện tại:
\begin{equation}
u_P = K_p \cdot e(t)
\end{equation}

$K_p$ càng lớn, hệ thống phản ứng càng nhanh với sai số. Tuy nhiên, nếu $K_p$ quá lớn, hệ thống có thể dao động hoặc mất ổn định. Thành phần P đơn thuần không thể triệt tiêu hoàn toàn sai số xác lập (steady-state error).

\textbf{Thành phần tích phân (I):}

Tích lũy sai số theo thời gian:
\begin{equation}
u_I = K_i \cdot \int_0^t e(\tau) \, d\tau
\end{equation}

Thành phần này giúp triệt tiêu sai số xác lập bằng cách tích lũy các sai số nhỏ theo thời gian. Tuy nhiên, $K_i$ quá lớn có thể gây hiện tượng vọt lố (overshoot) và làm chậm đáp ứng của hệ thống. Ngoài ra, cần chú ý hiện tượng ``windup'' khi tích phân tích lũy quá lớn trong các tình huống bão hòa.

\textbf{Thành phần vi phân (D):}

Dự đoán xu hướng thay đổi của sai số:
\begin{equation}
u_D = K_d \cdot \frac{de(t)}{dt}
\end{equation}

Thành phần này phản ứng với tốc độ thay đổi của sai số, giúp ``phanh'' hệ thống khi sai số đang giảm nhanh, từ đó giảm vọt lố và dao động. Nhược điểm là nhạy cảm với nhiễu tần số cao trong tín hiệu đo lường.

\subsection{Dạng rời rạc của PID cho hệ thống số}

Trong thực tế, vi điều khiển làm việc với tín hiệu rời rạc. Thuật toán PID được rời rạc hóa với chu kỳ lấy mẫu $T_s$:

\begin{equation}
u[k] = K_p \cdot e[k] + K_i \cdot T_s \sum_{j=0}^{k} e[j] + K_d \cdot \frac{e[k] - e[k-1]}{T_s}
\label{eq:pid_discrete}
\end{equation}

Thư viện PID\_v1 cho Arduino triển khai dạng rời rạc này với các tối ưu như: anti-windup (chống tích lũy tích phân khi bão hòa), derivative kick prevention (tránh đột biến vi phân khi thay đổi setpoint), và on-the-fly tuning (cho phép thay đổi tham số trong khi chạy).

\subsection{Phương pháp tinh chỉnh tham số PID}

Có nhiều phương pháp tinh chỉnh (tuning) tham số PID, từ các phương pháp giải tích (Ziegler-Nichols, Cohen-Coon) đến các phương pháp thử nghiệm. Trong dự án này, phương pháp thử-sai (Trial and Error) được áp dụng:

\textbf{Bước 1:} Đặt $K_i = K_d = 0$. Tăng dần $K_p$ cho đến khi hệ thống bắt đầu dao động liên tục quanh điểm cân bằng.

\textbf{Bước 2:} Giảm $K_p$ xuống khoảng 60-70\% giá trị gây dao động.

\textbf{Bước 3:} Tăng dần $K_d$ để giảm dao động và vọt lố. Thành phần D đặc biệt hiệu quả cho hệ thống có quán tính (như khối lượng đối trọng).

\textbf{Bước 4:} Nếu còn sai số xác lập (hệ thống không về đúng điểm cân bằng), thêm $K_i$ với giá trị nhỏ.

\textbf{Bước 5:} Lặp lại các bước trên để tinh chỉnh.

\section{Lập trình thời gian thực cho hệ thống nhúng}

\subsection{Khái niệm hệ thống thời gian thực}

Hệ thống thời gian thực (Real-time System) là hệ thống mà tính đúng đắn của kết quả không chỉ phụ thuộc vào giá trị logic của phép tính, mà còn phụ thuộc vào thời điểm kết quả được tạo ra. Trong ngữ cảnh điều khiển động cơ bước:

\begin{itemize}
    \item \textbf{Deadline:} Mỗi xung điều khiển phải được tạo ra đúng thời điểm (trong phạm vi jitter cho phép)
    \item \textbf{Hậu quả vi phạm deadline:} Động cơ mất bước, chạy giật cục, hoặc dừng hẳn
    \item \textbf{Loại hệ thống:} Soft real-time (vi phạm deadline gây suy giảm chất lượng, không gây hỏng hóc nghiêm trọng)
\end{itemize}

\subsection{Blocking vs Non-blocking I/O}

\textbf{Blocking I/O:} Khi thực hiện một thao tác I/O (đọc cảm biến, gửi dữ liệu Serial), CPU chờ đợi cho đến khi thao tác hoàn thành. Trong thời gian chờ, không có tác vụ nào khác được thực hiện.

\textbf{Non-blocking I/O:} Thao tác I/O được khởi tạo và trả về ngay lập tức. CPU có thể thực hiện các tác vụ khác trong khi chờ I/O hoàn thành. Khi I/O sẵn sàng, CPU được thông báo (qua polling hoặc interrupt).

Trong dự án này, các giải pháp non-blocking được áp dụng:
\begin{itemize}
    \item Thư viện HX711\_ADC với hàm \texttt{update()} non-blocking
    \item Giới hạn tần suất in Serial (mỗi 100ms thay vì mỗi vòng lặp)
    \item Sử dụng Baud Rate cao (115200) để giảm thời gian blocking khi buffer đầy
    \item Kiểm tra \texttt{Serial.availableForWrite()} trước khi gửi dữ liệu lớn
\end{itemize}

\subsection{Cơ chế Time-Slicing với millis()}

Time-Slicing là kỹ thuật phân chia thời gian CPU cho các tác vụ khác nhau dựa trên đồng hồ hệ thống. Trong Arduino, hàm \texttt{millis()} trả về số mili-giây kể từ khi khởi động.

Cấu trúc Time-Slicing điển hình:

\begin{lstlisting}[style=arduino]
unsigned long t_task1 = 0;
unsigned long t_task2 = 0;

void loop() {
    // Tac vu nen - chay moi vong lap
    stepper.runSpeed();
    LoadCell.update();

    // Tac vu 1 - chay moi 20ms
    if (millis() - t_task1 >= 20) {
        // Doc cam bien, tinh PID
        t_task1 = millis();
    }

    // Tac vu 2 - chay moi 100ms
    if (millis() - t_task2 >= 100) {
        // In thong tin Serial
        t_task2 = millis();
    }
}
\end{lstlisting}

Cơ chế này cho phép:
\begin{itemize}
    \item Tác vụ ưu tiên cao (\texttt{runSpeed()}) được gọi liên tục
    \item Tác vụ điều khiển (PID) chạy với tần số cố định (50Hz)
    \item Tác vụ giám sát (Serial) chạy với tần số thấp hơn (10Hz) để không ảnh hưởng đến các tác vụ quan trọng
\end{itemize}

\subsection{Vấn đề Pulse Starvation trong điều khiển động cơ bước}

Pulse Starvation (đói xung) là hiện tượng động cơ bước không nhận đủ xung điều khiển do CPU bận thực hiện các tác vụ khác. Hậu quả:

\begin{itemize}
    \item \textbf{Giảm tốc độ thực tế:} Thay vì 16000 bước/s, động cơ có thể chỉ đạt vài trăm bước/s
    \item \textbf{Mất đồng bộ từ trường:} Rotor không theo kịp từ trường stator, gây mất momen hoặc quay ngược
    \item \textbf{Rung lắc và tiếng ồn:} Xung không đều gây kích thích cộng hưởng cơ học
\end{itemize}

Để tránh Pulse Starvation:
\begin{itemize}
    \item Loại bỏ hoặc giảm thiểu các hàm blocking trong vòng lặp chính
    \item Đảm bảo thời gian thực thi của mỗi vòng lặp nhỏ hơn khoảng cách giữa các xung yêu cầu
    \item Sử dụng thư viện điều khiển động cơ dựa trên ngắt Timer (như FastAccelStepper) nếu cần tốc độ rất cao
\end{itemize}

\subsection{Kỹ thuật Deadzone và Hysteresis trong điều khiển}

\textbf{Deadzone (Vùng chết):}

Là vùng giá trị sai số mà hệ thống không phản ứng. Trong dự án này, Deadzone được đặt $\pm$50g:
\begin{itemize}
    \item Nếu $|e| \leq 50$g: Động cơ dừng, PID tắt
    \item Nếu $|e| > 50$g: PID hoạt động, động cơ di chuyển
\end{itemize}

Mục đích: Tránh động cơ chạy liên tục để bù các sai số nhỏ do nhiễu cảm biến hoặc rung động cơ học.

\textbf{Hysteresis (Độ trễ):}

Là kỹ thuật sử dụng hai ngưỡng khác nhau cho việc bật và tắt một chế độ:
\begin{itemize}
    \item Ngưỡng bật (Start threshold): 60g (= 50g + 10g hysteresis)
    \item Ngưỡng tắt (Stop threshold): 40g (= 50g - 10g hysteresis)
\end{itemize}

Logic hoạt động:
\begin{itemize}
    \item Nếu đang dừng và $|e| > 60$g: Bật chế độ cân bằng
    \item Nếu đang chạy và $|e| < 40$g: Tắt chế độ cân bằng
\end{itemize}

Mục đích: Tránh hiện tượng bật/tắt liên tục (chattering) khi sai số dao động quanh ngưỡng Deadzone.

\textbf{Minimum Speed Threshold (Ngưỡng tốc độ tối thiểu):}

Động cơ bước có vùng tốc độ thấp gây cộng hưởng và rung lắc. Giải pháp:
\begin{itemize}
    \item Nếu PID tính ra tốc độ $> 0$ nhưng $< 2000$ bước/s: Ép tốc độ lên 2000 bước/s
    \item Nếu PID tính ra tốc độ $= 0$ hoặc $\geq 2000$: Giữ nguyên
\end{itemize}

Điều này đảm bảo khi động cơ cần chạy, nó chạy ở tốc độ đủ cao để vượt qua vùng cộng hưởng.

%======================================================================
%======================================================================
% CHƯƠNG 3: THIẾT KẾ HỆ THỐNG (ĐÃ SỬA LỖI FLOAT)
%======================================================================
\chapter{Thiết kế hệ thống}

Chương này trình bày chi tiết quá trình thiết kế hệ thống khung đế cân bằng trọng tâm, bao gồm: phân tích yêu cầu thiết kế, thiết kế cơ khí, thiết kế mạch điện, và thiết kế phần mềm điều khiển.

\section{Phân tích yêu cầu thiết kế}

\subsection{Yêu cầu chức năng}

Dựa trên mục tiêu đề tài và phân tích ứng dụng thực tế, hệ thống cần đáp ứng các yêu cầu chức năng sau:

\textbf{F1 - Phát hiện độ lệch trọng tâm:} Hệ thống phải có khả năng đo lường sự chênh lệch trọng lượng giữa hai bên khung (trái và phải) với độ phân giải tối thiểu 10g.

\textbf{F2 - Bù đắp độ lệch tự động:} Khi phát hiện độ lệch vượt ngưỡng cho phép, hệ thống phải tự động di chuyển khối đối trọng để bù đắp, đưa trọng tâm về vị trí cân bằng.

\textbf{F3 - Xác định điểm gốc (Homing):} Khi khởi động, hệ thống phải có khả năng tự động xác định vị trí tham chiếu của khối đối trọng thông qua công tắc hành trình.

\textbf{F4 - Bảo vệ hành trình:} Hệ thống phải ngăn chặn khối đối trọng di chuyển vượt quá giới hạn cơ khí.

\textbf{F5 - Giám sát hoạt động:} Cung cấp khả năng theo dõi các thông số hoạt động thông qua giao diện Serial.

\subsection{Yêu cầu phi chức năng}

\textbf{NF1 - Kích thước:} Khung đế có kích thước 35$\times$35cm, phù hợp với robot di động cỡ nhỏ và vừa.

\textbf{NF2 - Thời gian đáp ứng:} Hệ thống phải bắt đầu di chuyển đối trọng trong vòng 100ms sau khi phát hiện độ lệch.

\textbf{NF3 - Độ ổn định:} Động cơ bước phải hoạt động mượt mà, không bị giật cục hay mất bước.

\textbf{NF4 - Độ chính xác cân bằng:} Sau khi cân bằng, độ lệch còn lại phải nằm trong vùng $\pm$50g.

\subsection{Ràng buộc thiết kế}

Quá trình thiết kế phải tuân thủ các ràng buộc: sử dụng linh kiện phổ biến tại Việt Nam (Arduino, Nema 17, TB6600, Loadcell 50kg, HX711); khung cơ khí dùng nhôm định hình 20$\times$20mm; và tốc độ tối đa của động cơ bị giới hạn khoảng 4000 bước/giây do giới hạn của thư viện AccelStepper.

\section{Thiết kế cơ khí}

\subsection{Tổng quan cấu trúc cơ khí}

Hệ thống cơ khí bao gồm các thành phần chính: khung đế hình vuông làm từ nhôm định hình, cơ cấu di chuyển đối trọng gồm vitme và thanh trượt, động cơ bước gắn ở một đầu vitme, các cụm loadcell gắn ở bốn góc khung, và công tắc hành trình để xác định điểm gốc. Bảng 3.1 trình bày thông số khung nhôm định hình.

\begin{table}[H]{Thông số khung nhôm định hình}
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Thông số} & \textbf{Giá trị} \\
\hline
Kích thước tổng thể & 350 $\times$ 350 mm \\
Tiết diện thanh nhôm & 20 $\times$ 20 mm \\
Vật liệu & Hợp kim nhôm 6063-T5 \\
Phương pháp liên kết & Ke góc vuông + bu-lông M5 \\
Khối lượng khung & Khoảng 1.2 kg \\
\hline
\end{tabular}
\end{table}

Lý do lựa chọn nhôm định hình: độ cứng vững cao nhờ tiết diện rỗng với các gân tăng cứng bên trong; dễ gia công và lắp ráp; linh hoạt nhờ rãnh chữ T cho phép gắn linh kiện ở bất kỳ vị trí nào; nhẹ với tỷ trọng 2.7 g/cm³; và khả năng tái sử dụng cao.

\subsection{Cơ cấu vitme - thanh trượt}

Cơ cấu di chuyển đối trọng sử dụng truyền động vitme-đai ốc kết hợp với thanh trượt tròn dẫn hướng. Bảng 3.2 trình bày thông số vitme.

\begin{table}[H]{Thông số vitme}
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Thông số} & \textbf{Giá trị} \\
\hline
Đường kính danh nghĩa & 8 mm \\
Bước ren (Pitch) & 2 mm \\
Chiều dài làm việc & 250 mm \\
Loại & Vitme bi hoặc vitme thang \\
\hline
\end{tabular}
\end{table}

Bước ren 2mm có nghĩa mỗi vòng quay của động cơ, khối trượt di chuyển 2mm. Tính toán tốc độ di chuyển tối đa với chế độ 1/16 microstep (3200 bước/vòng) và tốc độ xung tối đa 4000 bước/giây: $n_{max} = 4000/3200 \times 60 = 75$ RPM, suy ra $v_{max} = 75 \times 2 / 60 = 2.5$ mm/s. Tốc độ này khá chậm, để di chuyển hết hành trình 120mm cần khoảng 48 giây.

Thanh trượt tròn đường kính 8mm, chiều dài 280mm, vật liệu thép mạ cứng, số lượng 2 thanh song song với vitme. Thanh trượt có chức năng dẫn hướng cho khối trượt di chuyển thẳng và chống xoay.

\subsection{Bố trí cảm biến Loadcell}

Hệ thống sử dụng 4 loadcell 50kg được bố trí ở bốn góc khung, ghép thành 2 cụm (trái và phải). Cụm trái gồm 2 loadcell ở góc trái-trước và trái-sau, ghép thành cầu Wheatstone đầy đủ. Cụm phải gồm 2 loadcell ở góc phải-trước và phải-sau. Mỗi cụm kết nối với một module HX711 riêng biệt.

\subsection{Giới hạn hành trình}

Hành trình di chuyển của khối đối trọng được xác định từ vị trí tâm (0): giới hạn trái là -120mm (tương ứng -192000 bước), giới hạn phải là +110mm (tương ứng +176000 bước). Công tắc hành trình được lắp đặt ở vị trí giới hạn phải (+110mm) để xác định điểm gốc khi thực hiện Homing.

\section{Thiết kế mạch điện}

\subsection{Sơ đồ khối hệ thống}

Hệ thống điện tử bao gồm các khối chức năng chính: Khối cảm biến (2 cụm Loadcell kết nối với 2 module HX711), Khối xử lý trung tâm (Arduino Uno), Khối điều khiển động cơ (Driver TB6600 và động cơ bước Nema 17), Khối nguồn (12V cho động cơ, 5V cho mạch điều khiển), và Khối giới hạn hành trình (công tắc hành trình). Hình 3.1 thể hiện sơ đồ khối hệ thống.

\begin{figure}[H]{Sơ đồ khối hệ thống điện tử}
\centering
\includegraphics[width=0.95\textwidth]{hinh/so-do-khoi.png}
\end{figure}

\subsection{Danh sách linh kiện điện tử}

Bảng 3.3 liệt kê các linh kiện điện tử sử dụng trong hệ thống.

\begin{table}[H]{Danh sách linh kiện điện tử}
\centering
\begin{tabular}{|c|l|l|c|}
\hline
\textbf{STT} & \textbf{Linh kiện} & \textbf{Thông số} & \textbf{SL} \\
\hline
1 & Vi điều khiển Arduino & Uno hoặc Nano (ATmega328P) & 1 \\
2 & Module HX711 & ADC 24-bit cho loadcell & 2 \\
3 & Loadcell & 50kg, 3 dây (half-bridge) & 4 \\
4 & Driver TB6600 & 9-42V, 4A max & 1 \\
5 & Động cơ bước & Nema 17, 1.8°/bước, 1.5A & 1 \\
6 & Công tắc hành trình & Micro switch với cần gạt & 1 \\
7 & Nguồn xung & 12V 5A & 1 \\
\hline
\end{tabular}
\end{table}

\subsection{Sơ đồ kết nối chi tiết}

Kết nối giữa Arduino và các module HX711 được thể hiện trong Bảng 3.4.

\begin{table}[H]{Kết nối Arduino với các module HX711}
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Module} & \textbf{Chân HX711} & \textbf{Chân Arduino} & \textbf{Ghi chú} \\
\hline
HX711 Trái & VCC & 5V & Nguồn cấp \\
HX711 Trái & GND & GND & Mass chung \\
HX711 Trái & DT (DOUT) & Pin 4 & Dữ liệu \\
HX711 Trái & SCK & Pin 5 & Xung clock \\
\hline
HX711 Phải & VCC & 5V & Nguồn cấp \\
HX711 Phải & GND & GND & Mass chung \\
HX711 Phải & DT (DOUT) & Pin 6 & Dữ liệu \\
HX711 Phải & SCK & Pin 7 & Xung clock \\
\hline
\end{tabular}
\end{table}

Kết nối giữa Arduino và driver TB6600 được thể hiện trong Bảng 3.5.

\begin{table}[H]{Kết nối Arduino với driver TB6600}
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Chân TB6600} & \textbf{Chân Arduino} & \textbf{Chức năng} \\
\hline
PUL+ & Pin 8 & Tín hiệu xung bước \\
PUL- & GND & Mass tín hiệu \\
DIR+ & Pin 9 & Tín hiệu chiều quay \\
DIR- & GND & Mass tín hiệu \\
ENA+ & Không kết nối & Kích hoạt driver \\
ENA- & Không kết nối & (Bỏ trống = luôn bật) \\
\hline
\end{tabular}
\end{table}

Kết nối công tắc hành trình: chân NO (Normally Open) nối với Pin 10 của Arduino sử dụng INPUT\_PULLUP, chân COM nối với GND. Logic hoạt động: khi chưa nhấn, Pin 10 ở mức HIGH; khi nhấn (khối trượt chạm công tắc), Pin 10 xuống mức LOW.

\subsection{Cấu hình Driver TB6600}

Cấu hình DIP Switch trên TB6600: dòng điện đặt 1.5A theo bảng tra của TB6600, chế độ vi bước 1/16 (3200 pulse/rev) với SW4=ON, SW5=ON, SW6=OFF. Lưu ý cấu hình có thể khác nhau giữa các phiên bản TB6600, cần tham khảo datasheet của nhà sản xuất cụ thể.

\subsection{Sơ đồ nguyên lý mạch điện}

Hình 3.2 thể hiện sơ đồ nguyên lý mạch điện chi tiết của toàn bộ hệ thống, bao gồm các kết nối giữa Arduino, HX711, TB6600, động cơ bước, công tắc hành trình và nguồn điện.

\begin{figure}[H]{Sơ đồ nguyên lý mạch điện hệ thống}
\centering
\includegraphics[width=\textwidth]{hinh/so-do-nguyen-ly.png}
\end{figure}

\subsection{Thiết kế nguồn điện}

Hệ thống sử dụng hai nguồn điện riêng biệt. Nguồn 12V/5A cấp cho driver TB6600 và động cơ, công suất 60W dư so với yêu cầu của Nema 17. Nguồn 5V cấp từ cổng USB của Arduino cho Arduino, HX711 và các cảm biến, dòng tiêu thụ ước tính dưới 500mA. Lưu ý quan trọng: GND của nguồn 12V và GND của Arduino phải được nối chung để đảm bảo tín hiệu điều khiển hoạt động đúng.

\subsection{Xử lý nhiễu điện từ}

Động cơ bước và driver công suất có thể tạo ra nhiễu điện từ ảnh hưởng đến tín hiệu loadcell. Các biện pháp giảm nhiễu bao gồm: tách biệt nguồn cho động cơ và mạch điều khiển; xoắn dây tín hiệu loadcell theo dạng twisted pair; giữ dây kết nối ngắn nhất có thể (dưới 50cm); có thể thêm tụ điện 100nF gần chân nguồn của HX711; và áp dụng lọc phần mềm bằng cách làm tròn giá trị đọc (quantization).

\section{Thiết kế phần mềm}

\subsection{Kiến trúc phần mềm tổng quan}

Phần mềm điều khiển được thiết kế theo kiến trúc Superloop với Time-Slicing, đảm bảo tính non-blocking và đáp ứng các ràng buộc thời gian thực. Kiến trúc này chia thành ba tầng nhiệm vụ với độ ưu tiên và tần suất khác nhau:

Nhiệm vụ nền chạy mỗi vòng lặp (khoảng 10 $\mu$s) bao gồm gọi hàm LoadCell.update() để kiểm tra dữ liệu mới một cách non-blocking và gọi hàm stepper.runSpeed() để tạo xung nếu đến thời điểm.

Nhiệm vụ điều khiển chạy mỗi 20ms (tần số 50Hz) bao gồm đọc giá trị cảm biến, tính toán sai số, xử lý logic Deadzone và Hysteresis, tính toán PID, và cập nhật tốc độ động cơ.

Nhiệm vụ giám sát chạy mỗi 100ms (tần số 10Hz) bao gồm in các thông số ra Serial và hiển thị trạng thái hệ thống.

\subsection{Quy trình Homing}

Quy trình Homing xác định điểm gốc của hệ thống với độ chính xác cao thông qua phương pháp hai giai đoạn, được minh họa trong Hình 3.3.

\begin{figure}[H]{Lưu đồ quy trình Homing}
\centering
\includegraphics[width=0.65\textwidth]{hinh/luu-do-homing.png}
\end{figure}

\textbf{Giai đoạn 1 - Tìm nhanh:} Di chuyển khối trượt về phía công tắc hành trình với tốc độ cao 8000 bước/s. Khi chạm công tắc (Pin 10 xuống LOW), dừng ngay lập tức và ghi nhận vị trí tạm thời là MAX\_POS\_RIGHT.

\textbf{Giai đoạn 2 - Lùi ra và tìm chậm:} Lùi ra 5mm để nhả công tắc, kiểm tra công tắc đã nhả (Pin 10 lên HIGH), sau đó di chuyển chậm trở lại với tốc độ 4000 bước/s cho đến khi chạm công tắc lần thứ hai. Vị trí chạm lần hai là điểm gốc chính xác.

\textbf{Giai đoạn 3 - Di chuyển về tâm:} Thiết lập vị trí hiện tại là MAX\_POS\_RIGHT (+110mm), di chuyển đến vị trí 0 (tâm khung), và chờ 5 giây để loadcell ổn định trước khi bắt đầu cân bằng.

\subsection{Logic điều khiển PID với Deadzone và Hysteresis}

Logic điều khiển được thiết kế để tránh các vấn đề phổ biến trong hệ thống cân bằng, được minh họa trong Hình 3.4.

\begin{figure}[H]{Lưu đồ thuật toán điều khiển PID}
\centering
\includegraphics[width=0.75\textwidth]{hinh/luu-do-pid.png}
\end{figure}

\textbf{Vấn đề 1 - Dao động quanh điểm cân bằng (Hunting):} Nếu không có vùng chết, khi độ lệch về gần 0, PID vẫn tiếp tục điều chỉnh, gây ra dao động liên tục. Giải pháp là áp dụng Deadzone $\pm$50g.

\textbf{Vấn đề 2 - Bật/tắt liên tục (Chattering):} Nếu chỉ dùng một ngưỡng 50g, khi sai số dao động quanh ngưỡng này, hệ thống sẽ bật/tắt liên tục. Giải pháp là áp dụng Hysteresis $\pm$10g với ngưỡng bật 60g và ngưỡng tắt 40g.

\textbf{Vấn đề 3 - Động cơ rung ở tốc độ thấp:} Động cơ bước có các vùng tốc độ gây cộng hưởng và rung lắc. Giải pháp là áp dụng ngưỡng tốc độ tối thiểu 2000 bước/s.

\subsection{Xử lý giới hạn hành trình mềm}

Ngoài công tắc hành trình vật lý ở vị trí +110mm, phần mềm còn kiểm tra giới hạn mềm (soft limits) để ngăn khối trượt va chạm vào hai đầu. Nếu vị trí hiện tại đã đạt giới hạn trái và tốc độ đang âm (muốn đi tiếp sang trái), hệ thống ép tốc độ về 0. Tương tự cho giới hạn phải.

\subsection{Các tham số cấu hình}

Bảng 3.6 tổng hợp các tham số cấu hình của phần mềm.

\begin{table}[H]{Bảng tổng hợp các tham số cấu hình phần mềm}
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Tham số} & \textbf{Giá trị} & \textbf{Ý nghĩa} \\
\hline
MICROSTEP & 16 & Chế độ vi bước 1/16 \\
STEPS\_PER\_MM & 1600 & Số bước trên 1mm \\
MAX\_POS\_RIGHT & +176000 & Giới hạn phải (bước) \\
MAX\_POS\_LEFT & -192000 & Giới hạn trái (bước) \\
\hline
MAX\_SPEED\_PID & 8000 & Tốc độ tối đa (bước/s) \\
MOTOR\_ACCEL & 16000 & Gia tốc (bước/s²) \\
MIN\_SPEED\_THRESHOLD & 2000 & Tốc độ tối thiểu \\
\hline
Kp & 25.0 & Hệ số tỷ lệ PID \\
Ki & 0.05 & Hệ số tích phân PID \\
Kd & 0 & Hệ số vi phân PID \\
\hline
ACCEPTABLE\_RANGE & 50.0 & Vùng chết (g) \\
HYSTERESIS\_GAP & 10.0 & Độ trễ (g) \\
STEP\_SIZE & 10.0 & Độ chia quantization (g) \\
\hline
PID\_INTERVAL & 20 & Chu kỳ tính PID (ms) \\
PRINT\_INTERVAL & 100 & Chu kỳ in Serial (ms) \\
\hline
\end{tabular}
\end{table}

\subsection{Quy trình hiệu chuẩn Loadcell}

Trước khi sử dụng, mỗi cụm loadcell cần được hiệu chuẩn để xác định hệ số chuyển đổi. Quy trình gồm 5 bước: nạp chương trình hiệu chuẩn từ ví dụ của thư viện HX711\_ADC; đảm bảo không có tải trên loadcell và thực hiện lệnh tare về 0; đặt vật chuẩn có khối lượng đã biết (ví dụ 500g) lên loadcell; điều chỉnh hệ số hiệu chuẩn cho đến khi giá trị đọc được bằng khối lượng vật chuẩn; và ghi nhận hệ số hiệu chuẩn để cập nhật vào chương trình chính.

Trong dự án này, hệ số hiệu chuẩn đã xác định là CALIB\_LEFT = -53.13 và CALIB\_RIGHT = -55.36. Dấu âm là do cách lắp đặt loadcell theo chiều nén.

%======================================================================
% CHƯƠNG 4: THỰC NGHIỆM VÀ ĐÁNH GIÁ
%======================================================================

\chapter{Thực nghiệm và đánh giá}

Chương này trình bày quá trình triển khai thực tế hệ thống khung cân bằng trọng tâm, các kịch bản thử nghiệm, kết quả đo đạc và đánh giá hiệu năng của hệ thống.

\section{Triển khai hệ thống}

\subsection{Môi trường thử nghiệm}

Hệ thống được triển khai và thử nghiệm trong điều kiện phòng thí nghiệm với các thông số môi trường:

\begin{itemize}
    \item Nhiệt độ phòng: 25--30°C
    \item Mặt sàn: Phẳng, cứng (gạch men)
    \item Nguồn điện: Ổn định 220V AC, chuyển đổi sang 12V DC và 5V DC
    \item Không có rung động ngoại lai đáng kể
\end{itemize}

\subsection{Quy trình hiệu chuẩn Loadcell}

Trước khi tiến hành thử nghiệm, hệ thống Loadcell được hiệu chuẩn theo quy trình sau:

\textbf{Bước 1: Xác định hệ số hiệu chuẩn (Calibration Factor)}

Sử dụng vật chuẩn có khối lượng đã biết (quả cân 500g), đặt lên từng cụm Loadcell và điều chỉnh hệ số cho đến khi giá trị đọc được khớp với khối lượng thực.

\begin{itemize}
    \item Hệ số hiệu chuẩn Loadcell Trái: $-53.13$
    \item Hệ số hiệu chuẩn Loadcell Phải: $-55.36$
\end{itemize}

\textbf{Bước 2: Trừ bì (Tare)}

Khi khởi động hệ thống, thực hiện trừ bì tự động để đưa giá trị đọc về 0 khi không có tải.

\textbf{Bước 3: Kiểm tra độ tuyến tính}

Đặt các vật có khối lượng khác nhau (100g, 200g, 500g, 1000g) và kiểm tra độ chính xác của giá trị đọc.

\subsection{Quy trình Homing}

Quy trình Homing được thực hiện tự động mỗi khi khởi động hệ thống:

\begin{enumerate}
    \item \textbf{Tìm nhanh}: Động cơ chạy về phía công tắc hành trình với tốc độ 8000 bước/s cho đến khi chạm công tắc.
    \item \textbf{Lùi ra}: Động cơ lùi ra 5mm để nhả công tắc.
    \item \textbf{Tìm chậm}: Động cơ chạy chậm (4000 bước/s) về phía công tắc để xác định vị trí chính xác.
    \item \textbf{Thiết lập gốc}: Gán vị trí hiện tại là +110mm (giới hạn phải).
    \item \textbf{Về tâm}: Động cơ di chuyển về vị trí 0mm (tâm khung).
    \item \textbf{Chờ ổn định}: Hệ thống chờ 5 giây để Loadcell ổn định trước khi bắt đầu cân bằng.
\end{enumerate}

Thời gian hoàn thành quy trình Homing: khoảng 15--20 giây.

\section{Kịch bản thử nghiệm}

\subsection{Thử nghiệm 1: Đáp ứng với tải tĩnh}

\textbf{Mục đích}: Đánh giá khả năng cân bằng khi đặt tải cố định lên một bên khung.

\textbf{Quy trình}:
\begin{enumerate}
    \item Khởi động hệ thống, chờ Homing hoàn tất.
    \item Đặt vật nặng (100g, 200g, 300g) lên phía bên phải khung.
    \item Quan sát phản ứng của hệ thống và ghi nhận thời gian đạt cân bằng.
    \item Lặp lại với các khối lượng khác nhau.
\end{enumerate}

\textbf{Kết quả}:

\begin{table}[H]{Kết quả thử nghiệm đáp ứng với tải tĩnh}
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{Tải đặt (g)} & \textbf{Độ lệch ban đầu (g)} & \textbf{Thời gian đáp ứng (s)} & \textbf{Độ lệch cuối (g)} & \textbf{Kết quả} \\
\hline
100 & 95--105 & 2.1 & $<$50 & Đạt \\
\hline
200 & 190--210 & 3.5 & $<$50 & Đạt \\
\hline
300 & 285--310 & 4.8 & $<$50 & Đạt \\
\hline
500 & 480--520 & 7.2 & $<$50 & Đạt \\
\hline
\end{tabular}
\end{table}

\textbf{Nhận xét}: Hệ thống đáp ứng tốt với tải tĩnh trong phạm vi 100--500g. Thời gian đáp ứng tỷ lệ thuận với độ lớn của tải. Độ lệch cuối cùng đều nằm trong vùng chấp nhận (±50g).

\subsection{Thử nghiệm 2: Đáp ứng với tải thay đổi đột ngột}

\textbf{Mục đích}: Đánh giá khả năng phản ứng khi tải thay đổi đột ngột (mô phỏng cánh tay robot gắp/thả vật).

\textbf{Quy trình}:
\begin{enumerate}
    \item Hệ thống đang ở trạng thái cân bằng.
    \item Đặt nhanh vật 200g lên một bên.
    \item Ghi nhận thời gian hệ thống phát hiện và bắt đầu phản ứng.
    \item Ghi nhận thời gian đạt cân bằng trở lại.
    \item Nhấc vật ra và quan sát phản ứng ngược lại.
\end{enumerate}

\textbf{Kết quả}:

\begin{table}[H]{Kết quả thử nghiệm đáp ứng với tải thay đổi đột ngột}
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Thông số} & \textbf{Đặt tải} & \textbf{Nhấc tải} \\
\hline
Thời gian phát hiện (ms) & $<$100 & $<$100 \\
\hline
Thời gian bắt đầu di chuyển (ms) & $<$150 & $<$150 \\
\hline
Thời gian đạt cân bằng (s) & 3.2 & 2.8 \\
\hline
Độ vọt lố (g) & $<$30 & $<$25 \\
\hline
\end{tabular}
\end{table}

\textbf{Nhận xét}: Hệ thống phát hiện thay đổi tải nhanh chóng (dưới 100ms) nhờ chu kỳ lấy mẫu 20ms của PID. Độ vọt lố thấp cho thấy tham số PID được tinh chỉnh phù hợp.

\subsection{Thử nghiệm 3: Độ ổn định dài hạn}

\textbf{Mục đích}: Đánh giá độ ổn định của hệ thống khi hoạt động liên tục trong thời gian dài.

\textbf{Quy trình}:
\begin{enumerate}
    \item Đặt tải 200g lên một bên, chờ hệ thống cân bằng.
    \item Để hệ thống hoạt động liên tục trong 30 phút.
    \item Ghi nhận giá trị độ lệch mỗi 5 phút.
    \item Quan sát hiện tượng trôi (drift) hoặc dao động.
\end{enumerate}

\textbf{Kết quả}:

\begin{table}[H]{Kết quả thử nghiệm độ ổn định dài hạn}
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Thời gian (phút)} & \textbf{Độ lệch (g)} & \textbf{Vị trí con trượt (mm)} & \textbf{Trạng thái} \\
\hline
0 & 45 & -32.5 & OK \\
\hline
5 & 42 & -32.8 & OK \\
\hline
10 & 48 & -32.3 & OK \\
\hline
15 & 44 & -32.6 & OK \\
\hline
20 & 46 & -32.4 & OK \\
\hline
25 & 43 & -32.7 & OK \\
\hline
30 & 45 & -32.5 & OK \\
\hline
\end{tabular}
\end{table}

\textbf{Nhận xét}: Hệ thống duy trì trạng thái cân bằng ổn định trong suốt 30 phút thử nghiệm. Không xuất hiện hiện tượng trôi đáng kể. Độ lệch dao động trong khoảng ±5g quanh giá trị trung bình, nằm trong vùng Deadzone nên động cơ không hoạt động liên tục.

\subsection{Thử nghiệm 4: Giới hạn khả năng cân bằng}

\textbf{Mục đích}: Xác định giới hạn tải tối đa mà hệ thống có thể cân bằng.

\textbf{Quy trình}:
\begin{enumerate}
    \item Tăng dần khối lượng tải từ 100g đến khi hệ thống không thể cân bằng.
    \item Ghi nhận vị trí con trượt và độ lệch còn lại.
\end{enumerate}

\textbf{Kết quả}:

Với con trượt đối trọng nặng 200g và hành trình tối đa 120mm:
\begin{itemize}
    \item Tải cân bằng được: $\le$ 600g (con trượt chưa chạm giới hạn)
    \item Tải vượt khả năng: $>$ 700g (con trượt chạm giới hạn, còn lệch $>$50g)
\end{itemize}

Kết quả này phù hợp với tính toán lý thuyết về momen cân bằng:
$m_{slider} \times d_{slider} = m_{load} \times d_{load}$
$200g \times 120mm = 600g \times 40mm$

\textbf{Nhận xét}: Giới hạn cân bằng phụ thuộc vào khối lượng đối trọng và hành trình. Để tăng khả năng cân bằng, cần tăng khối lượng con trượt hoặc mở rộng hành trình.

\section{Phân tích kết quả}

\subsection{Hiệu năng bộ điều khiển PID}

Với bộ tham số PID đã tinh chỉnh ($K_p = 25$, $K_i = 0.05$, $K_d = 0$):

\begin{itemize}
    \item \textbf{Thời gian xác lập}: 2--5 giây tùy độ lớn nhiễu loạn
    \item \textbf{Độ vọt lố}: $<$30g (trong phạm vi Deadzone)
    \item \textbf{Sai số xác lập}: 0g (nhờ thành phần I, tuy nhỏ)
    \item \textbf{Độ ổn định}: Không dao động, không hunting
\end{itemize}

Thành phần $K_d = 0$ được chọn vì:
\begin{itemize}
    \item Tín hiệu Loadcell đã được làm tròn (Quantization 10g) giúp giảm nhiễu
    \item Cơ cấu vitme có quán tính thấp, không cần giảm chấn mạnh
    \item Tránh khuếch đại nhiễu từ đạo hàm
\end{itemize}

\subsection{Hiệu quả cơ chế Deadzone và Hysteresis}

Cơ chế Deadzone (±50g) và Hysteresis (±10g) mang lại các lợi ích:

\begin{itemize}
    \item \textbf{Tiết kiệm năng lượng}: Động cơ dừng hoàn toàn khi đã cân bằng
    \item \textbf{Giảm mài mòn}: Không chạy qua chạy lại liên tục
    \item \textbf{Giảm tiếng ồn}: Hệ thống yên tĩnh khi ở trạng thái cân bằng
    \item \textbf{Tránh hunting}: Ngưỡng bật ($>$60g) khác ngưỡng tắt ($<$40g) ngăn dao động
\end{itemize}

\subsection{Hiệu quả thiết kế Non-blocking}

So sánh với thiết kế Blocking (sử dụng \texttt{get\_units()} và \texttt{delay()}):

\begin{table}[H]{So sánh thiết kế Non-blocking và Blocking}
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Tiêu chí} & \textbf{Non-blocking} & \textbf{Blocking} \\
\hline
Tần số gọi \texttt{runSpeed()} & $\sim$100 kHz & $\sim$40 Hz \\
\hline
Tốc độ động cơ tối đa & 8000 bước/s & $<$100 bước/s \\
\hline
Độ mượt chuyển động & Rất mượt & Giật cục, kêu rít \\
\hline
Chu kỳ lấy mẫu PID & 20ms (ổn định) & Không ổn định \\
\hline
\end{tabular}
\end{table}

Kết quả cho thấy thiết kế Non-blocking là bắt buộc để hệ thống hoạt động đúng chức năng.

\section{Đánh giá tổng thể}

\subsection{Ưu điểm của hệ thống}

\begin{enumerate}
    \item \textbf{Đáp ứng yêu cầu chức năng}: Cân bằng được tải trong phạm vi thiết kế (0--600g)
    \item \textbf{Độ chính xác}: Độ lệch cuối cùng $<$50g, phù hợp ứng dụng thực tế
    \item \textbf{Ổn định}: Không dao động, duy trì cân bằng dài hạn
    \item \textbf{Tiết kiệm năng lượng}: Động cơ dừng sau khi cân bằng
    \item \textbf{Chi phí thấp}: Sử dụng linh kiện phổ biến, dễ tìm
    \item \textbf{Dễ mở rộng}: Kiến trúc phần mềm rõ ràng, dễ thêm tính năng
\end{enumerate}

\subsection{Hạn chế và nguyên nhân}

\begin{enumerate}
    \item \textbf{Thời gian đáp ứng chậm (2--5s)}:
    \begin{itemize}
        \item Nguyên nhân: Vitme bước 2mm, tốc độ di chuyển tối đa $\sim$5mm/s
        \item Giải pháp: Dùng vitme bước lớn hơn (4--8mm) hoặc đai răng
    \end{itemize}

    \item \textbf{Giới hạn tải ($<$600g)}:
    \begin{itemize}
        \item Nguyên nhân: Khối lượng đối trọng nhỏ (200g), hành trình hạn chế
        \item Giải pháp: Tăng khối lượng đối trọng, mở rộng hành trình
    \end{itemize}

    \item \textbf{Chưa có giao diện người dùng}:
    \begin{itemize}
        \item Nguyên nhân: Tập trung vào chức năng cốt lõi
        \item Giải pháp: Thêm màn hình LCD hoặc ứng dụng Bluetooth
    \end{itemize}
\end{enumerate}

\subsection{So sánh với mục tiêu đề ra}

\begin{table}[H]{So sánh kết quả với mục tiêu}
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Mục tiêu} & \textbf{Yêu cầu} & \textbf{Kết quả} & \textbf{Đánh giá} \\
\hline
Phát hiện độ lệch & Có & Có & Đạt \\
\hline
Tự động cân bằng & Có & Có & Đạt \\
\hline
Độ chính xác & ±100g & ±50g & Vượt \\
\hline
Thời gian đáp ứng & $<$10s & 2--5s & Đạt \\
\hline
Hoạt động ổn định & $>$30 phút & $>$30 phút & Đạt \\
\hline
Chi phí & Thấp & $<$1 triệu VNĐ & Đạt \\
\hline
\end{tabular}
\end{table}

Kết luận: Hệ thống đáp ứng đầy đủ các mục tiêu đề ra, một số chỉ tiêu vượt yêu cầu.

%======================================================================
% CHƯƠNG 5: KẾT LUẬN VÀ HƯỚNG PHÁT TRIỂN
%======================================================================
\chapter{Kết luận và hướng phát triển}

\section{Kết quả đạt được}

Khóa luận đã hoàn thành các mục tiêu đề ra:

Về lý thuyết: Nghiên cứu và trình bày đầy đủ cơ sở lý thuyết về cân bằng trọng tâm, cảm biến lực, động cơ bước, thuật toán PID và lập trình thời gian thực cho hệ thống nhúng.

Về thiết kế: Thiết kế hoàn chỉnh hệ thống khung đế cân bằng bao gồm cơ khí (khung nhôm, cơ cấu vitme-thanh trượt), mạch điện (kết nối Arduino, HX711, TB6600), và phần mềm điều khiển.

Về chế tạo: Chế tạo thành công mô hình khung đế hoạt động ổn định. Hệ thống có khả năng phát hiện và bù đắp độ lệch trọng tâm trong phạm vi thiết kế.

Về phần mềm: Xây dựng chương trình điều khiển theo kiến trúc Non-blocking, đảm bảo động cơ bước hoạt động mượt mà. Tích hợp thuật toán PID với các kỹ thuật Deadzone, Hysteresis và Min Speed Cutoff.

\section{Hạn chế của đề tài}

Tốc độ phản hồi: Do sử dụng vitme bước nhỏ (2mm) kết hợp microstep cao (1/16), tốc độ di chuyển đối trọng chỉ đạt 2.5mm/s, chưa đáp ứng được các tình huống thay đổi tải đột ngột.

Khả năng cân bằng: Với đối trọng 200g, hệ thống chỉ bù đắp được độ lệch tối đa khoảng 137g. Để cân bằng tải lớn hơn cần tăng khối lượng đối trọng.

Phạm vi cân bằng: Hệ thống chỉ cân bằng theo một trục. Robot thực tế có thể cần cân bằng theo cả hai trục.

\section{Hướng phát triển}

Tăng tốc độ phản hồi: Sử dụng vitme bước lớn hơn (4mm hoặc 8mm) hoặc giảm microstep xuống 1/4 để tăng tốc độ di chuyển.

Tăng khả năng cân bằng: Sử dụng đối trọng nặng hơn (có thể tận dụng pin/acquy của robot) hoặc thiết kế cơ cấu có cánh tay đòn dài hơn.

Mở rộng sang hai trục: Thiết kế thêm cơ cấu di chuyển đối trọng theo trục trước-sau để cân bằng hoàn toàn.

Điều khiển vị trí và tốc độ: Như yêu cầu mở rộng của đề tài, có thể phát triển thêm chế độ điều khiển vị trí tuyệt đối và giới hạn tốc độ chuyển dịch của đối trọng.

Tích hợp vào robot thực tế: Thiết kế phiên bản nhỏ gọn hơn, tối ưu nguồn điện và giao tiếp với hệ thống điều khiển chính của robot.

%======================================================================
% CHƯƠNG 5: KẾT LUẬN VÀ HƯỚNG PHÁT TRIỂN
%======================================================================

\chapter{Kết luận và hướng phát triển}

\section{Kết luận}

Khóa luận đã hoàn thành việc nghiên cứu, thiết kế và xây dựng hệ thống khung đế robot có khả năng tự động cân bằng trọng tâm sử dụng phương pháp khối lượng di động (Moving Mass). Các kết quả đạt được bao gồm:

\subsection{Về mặt lý thuyết}

\begin{enumerate}
    \item Phân tích và so sánh các phương pháp cân bằng robot: điều khiển bánh xe, bánh đà/CMG, khối lượng di động, và mở rộng đa giác đỡ. Từ đó lựa chọn phương pháp phù hợp với yêu cầu đề tài.

    \item Nghiên cứu nguyên lý hoạt động của cảm biến Loadcell và module HX711, đặc biệt là cơ chế Non-blocking của thư viện HX711\_ADC giúp giải quyết xung đột tần số giữa cảm biến chậm và điều khiển động cơ nhanh.

    \item Tìm hiểu lý thuyết điều khiển PID và các kỹ thuật cải tiến như Deadzone, Hysteresis, Min Speed Threshold để tăng độ ổn định thực tế.

    \item Phân tích vấn đề thời gian thực trong hệ thống nhúng, đặc biệt là tác động của Blocking I/O đến hiệu năng điều khiển động cơ bước.
\end{enumerate}

\subsection{Về mặt thực tiễn}

\begin{enumerate}
    \item Thiết kế và chế tạo thành công khung cơ khí sử dụng nhôm định hình 20x20mm, vitme bước 2mm, và thanh trượt tuyến tính. Kích thước khung 35x35cm phù hợp với robot di động cỡ nhỏ và vừa.

    \item Xây dựng hệ thống điện tử với Arduino Uno làm bộ xử lý trung tâm, 2 module HX711 đọc 4 Loadcell 50kg (2 cụm Trái/Phải), driver TB6600 điều khiển động cơ Nema 17.

    \item Phát triển phần mềm điều khiển hoàn chỉnh bao gồm:
    \begin{itemize}
        \item Quy trình Homing tự động 2 giai đoạn (nhanh + chậm)
        \item Thuật toán PID với các tham số đã tinh chỉnh ($K_p=25$, $K_i=0.05$, $K_d=0$)
        \item Cơ chế Deadzone (±50g) và Hysteresis (±10g)
        \item Giới hạn hành trình mềm bảo vệ cơ khí
        \item Kiến trúc Non-blocking đảm bảo động cơ chạy mượt
    \end{itemize}

    \item Thử nghiệm và đánh giá hệ thống với kết quả:
    \begin{itemize}
        \item Cân bằng được tải trong phạm vi 0--600g
        \item Độ chính xác ±50g (vượt yêu cầu ±100g)
        \item Thời gian đáp ứng 2--5 giây
        \item Hoạt động ổn định liên tục trên 30 phút
        \item Chi phí linh kiện dưới 1 triệu VNĐ
    \end{itemize}
\end{enumerate}

\subsection{Đóng góp của đề tài}

\begin{enumerate}
    \item Đề xuất giải pháp cân bằng trọng tâm sử dụng Loadcell thay vì IMU, phù hợp với ứng dụng cân bằng tĩnh và bán tĩnh khi tải thay đổi.

    \item Giải quyết vấn đề tích hợp cảm biến chậm (Loadcell 10--80Hz) với điều khiển nhanh (động cơ bước kHz) thông qua kiến trúc Non-blocking.

    \item Cung cấp bộ mã nguồn Arduino hoàn chỉnh, có thể tái sử dụng và mở rộng cho các ứng dụng tương tự.

    \item Xây dựng tài liệu kỹ thuật chi tiết về thiết kế, triển khai và tinh chỉnh hệ thống cân bằng.
\end{enumerate}

\section{Hạn chế}

Bên cạnh các kết quả đạt được, đề tài còn một số hạn chế:

\begin{enumerate}
    \item \textbf{Tốc độ đáp ứng}: Thời gian cân bằng 2--5 giây có thể chưa đủ nhanh cho các ứng dụng yêu cầu phản ứng tức thời. Nguyên nhân chính là vitme bước 2mm có tốc độ di chuyển thấp.

    \item \textbf{Giới hạn tải}: Khả năng cân bằng tối đa 600g bị giới hạn bởi khối lượng đối trọng (200g) và hành trình (120mm). Chưa thử nghiệm với tải lớn hơn.

    \item \textbf{Một trục}: Hệ thống chỉ cân bằng theo một trục (Trái-Phải). Chưa mở rộng cho cân bằng 2 trục (Trước-Sau).

    \item \textbf{Giao diện}: Chưa có giao diện người dùng trực quan, chỉ giám sát qua Serial Monitor.

    \item \textbf{Tích hợp}: Chưa tích hợp thực tế với robot di động để đánh giá hiệu quả trong điều kiện vận hành.
\end{enumerate}

\section{Hướng phát triển}

Dựa trên kết quả và hạn chế của đề tài, các hướng phát triển tiếp theo bao gồm:

\subsection{Cải tiến phần cứng}

\begin{enumerate}
    \item \textbf{Tăng tốc độ di chuyển}: Thay vitme bước 2mm bằng vitme bước 4--8mm hoặc hệ thống đai răng (belt drive) để tăng tốc độ đáp ứng lên 2--3 lần.

    \item \textbf{Mở rộng 2 trục}: Thêm một cơ cấu vitme + đối trọng theo trục Trước-Sau để cân bằng hoàn toàn trên mặt phẳng.

    \item \textbf{Tăng khả năng chịu tải}: Sử dụng đối trọng nặng hơn (500g--1kg) hoặc tận dụng pin/acquy của robot làm đối trọng di động.

    \item \textbf{Nâng cấp vi điều khiển}: Chuyển sang ESP32 hoặc STM32 để có tốc độ xử lý cao hơn, hỗ trợ WiFi/Bluetooth, và nhiều timer phần cứng cho điều khiển chính xác hơn.
\end{enumerate}

\subsection{Cải tiến phần mềm}

\begin{enumerate}
    \item \textbf{Thuật toán điều khiển nâng cao}: Nghiên cứu áp dụng LQR (Linear Quadratic Regulator) hoặc MPC (Model Predictive Control) để tối ưu đáp ứng.

    \item \textbf{Bộ lọc Kalman}: Tích hợp bộ lọc Kalman để kết hợp dữ liệu từ Loadcell và IMU, tăng độ chính xác và tốc độ phản hồi.

    \item \textbf{Adaptive PID}: Phát triển PID tự thích nghi, tự động điều chỉnh tham số theo đặc tính tải.

    \item \textbf{Giao diện người dùng}: Xây dựng ứng dụng di động (Android/iOS) hoặc giao diện web để giám sát và điều khiển từ xa qua Bluetooth/WiFi.
\end{enumerate}

\subsection{Tích hợp và ứng dụng}

\begin{enumerate}
    \item \textbf{Tích hợp robot thực tế}: Lắp đặt khung cân bằng lên robot di động có cánh tay gắp để đánh giá hiệu quả trong điều kiện vận hành thực.

    \item \textbf{Phối hợp với hệ thống điều khiển robot}: Kết nối với ROS (Robot Operating System) để tích hợp vào hệ thống điều khiển tổng thể của robot.

    \item \textbf{Ứng dụng công nghiệp}: Phát triển phiên bản công nghiệp với độ bền cao hơn, phù hợp môi trường nhà máy.
\end{enumerate}

\section{Lời kết}

Khóa luận đã hoàn thành mục tiêu đề ra là xây dựng hệ thống khung đế robot có khả năng tự động cân bằng trọng tâm. Mặc dù còn một số hạn chế, hệ thống đã chứng minh tính khả thi của phương pháp khối lượng di động kết hợp cảm biến Loadcell cho ứng dụng cân bằng robot.

Các kiến thức và kinh nghiệm thu được trong quá trình thực hiện đề tài, từ thiết kế cơ khí, điện tử đến lập trình nhúng và điều khiển tự động, là nền tảng quý giá cho việc nghiên cứu và phát triển các hệ thống robot phức tạp hơn trong tương lai.

Em xin chân thành cảm ơn thầy giáo hướng dẫn ThS. Đặng Anh Việt đã tận tình chỉ bảo và hỗ trợ em trong suốt quá trình thực hiện khóa luận này.

%======================================================================
% TÀI LIỆU THAM KHẢO (10 MỤC THIẾT YẾU)
% Chèn vào cuối khóa luận, sau Chương 5
%======================================================================

\begin{thebibliography}{10}

%----------------------------------------------------------------------
% TIẾNG VIỆT
%----------------------------------------------------------------------
\begin{bibsection}{Tiếng Việt}

\bibitem{phamthanhvu2015}
    Phạm Thanh Vũ,
    \textit{Nghiên cứu các luật điều khiển hiện đại trên mô hình robot cân bằng},
    Luận văn Thạc sĩ, Trường Đại học Công nghệ, Đại học Quốc gia Hà Nội, 2015.

\end{bibsection}

%----------------------------------------------------------------------
% TIẾNG ANH
%----------------------------------------------------------------------
\begin{bibsection}{Tiếng Anh}

% --- Thư viện phần mềm sử dụng trực tiếp ---
\bibitem{kallhovd2017hx711adc}
    O. Kallhovd,
    ``HX711\_ADC: Arduino library for the HX711 24-bit ADC for weight scales'',
    GitHub Repository, 2017.
    Truy cập: https://github.com/olkal/HX711\_ADC

\bibitem{airspayce2023accelstepper}
    M. McCauley,
    ``AccelStepper: Arduino library for stepper motors with acceleration/deceleration'',
    AirSpayce Documentation, 2023.
    Truy cập: https://www.airspayce.com/mikem/arduino/AccelStepper/

\bibitem{pid2012arduino}
    B. Beauregard,
    ``PID\_v1: Arduino PID Library'',
    GitHub Repository, 2012.
    Truy cập: https://github.com/br3ttb/Arduino-PID-Library

% --- Datasheet linh kiện ---
\bibitem{avia2014hx711}
    Avia Semiconductor,
    ``HX711: 24-Bit Analog-to-Digital Converter (ADC) for Weigh Scales'',
    Datasheet, Avia Semiconductor Co., Ltd., 2014.

\bibitem{atmega328p}
    Microchip Technology Inc.,
    ``ATmega328P: 8-bit AVR Microcontroller with 32K Bytes In-System Programmable Flash'',
    Datasheet, Microchip Technology Inc., 2018.

% --- Lý thuyết nền tảng ---
\bibitem{astrom2006pid}
    K. J. Åström and T. Hägglund,
    \textit{Advanced PID Control},
    ISA - The Instrumentation, Systems, and Automation Society, 2006.

\bibitem{siegwart2011mobile}
    R. Siegwart, I. R. Nourbakhsh, and D. Scaramuzza,
    \textit{Introduction to Autonomous Mobile Robots},
    2nd ed., MIT Press, 2011.

% --- Nghiên cứu liên quan ---
\bibitem{mdpi2024sbr}
    MDPI Robotics,
    ``Self-Balancing Mobile Robot: Design, Implementation, and Performance Analysis'',
    \textit{MDPI Robotics},
    vol. 6, no. 3, 2024.

\bibitem{researchgate2018cmg}
    ResearchGate,
    ``Development of a self-balancing robot with a control moment gyroscope'',
    \textit{ResearchGate Publication},
    April 2018.

\end{bibsection}

\end{thebibliography}

%======================================================================
% PHỤ LỤC
%======================================================================
\appendix

\chapter{Mã nguồn chương trình điều khiển}

Dưới đây là mã nguồn hoàn chỉnh của chương trình điều khiển khung cân bằng trọng tâm:

\begin{lstlisting}[style=arduino, caption={Chương trình điều khiển khung cân bằng trọng tâm}]
/*
 * DU AN KHUNG CAN BANG - PHIEN BAN HOAN CHINH
 * Tinh nang:
 * 1. Non-blocking: Dong co chay muot, khong bi khung khi doc cam bien.
 * 2. PID Control: Dieu khien vi tri con truot theo sai so trong luong.
 * 3. Deadzone: Vung chet +/- 50g giup dong co nghi ngoi khi da can bang.
 * 4. Quantization: Lam tron gia tri doc ve boi so cua 10g de giam nhieu.
 */

#include <HX711_ADC.h>
#include <AccelStepper.h>
#include <PID_v1.h>

// === CAU HINH HE THONG ===
const int DOUT_PIN_LEFT = 4; const int SCK_PIN_LEFT = 5;
const int DOUT_PIN_PHAI = 6; const int SCK_PIN_PHAI = 7;
const int STEP_PIN = 8;
const int DIR_PIN = 9;
const int HOME_SWITCH_PIN = 10;

// --- THONG SO CO KHI ---
const int MICROSTEP = 16;
const int MOTOR_STEP = 200;
const int PITCH = 2;
const float STEPS_PER_MM = (float)(MOTOR_STEP * MICROSTEP) / PITCH;

// --- GIOI HAN HANH TRINH ---
const long MAX_POS_RIGHT = 110.0 * STEPS_PER_MM;
const long MAX_POS_LEFT = -120.0 * STEPS_PER_MM;

// --- TOC DO & GIA TOC ---
const float MAX_SPEED_PID = 8000.0;
const float MOTOR_ACCEL = 16000.0;
const float HOMING_SPEED_FAST = 8000.0;
const float HOMING_SPEED_SLOW = 4000.0;

// --- CAU HINH CHONG RUNG ---
const float MIN_SPEED_THRESHOLD = 2000.0;
const float HYSTERESIS_GAP = 10.0;

// --- CAU HINH PID ---
double Kp = 25.0;
double Ki = 0.05;
double Kd = 0;
double Setpoint = 0, Input, Output;
PID myPID(&Input, &Output, &Setpoint, Kp, Ki, Kd, DIRECT);

// --- HIEU CHUAN ---
float CALIB_LEFT = -53.13;
float CALIB_RIGHT = -55.36;
const float ACCEPTABLE_RANGE = 50.0;
const float STEP_SIZE = 10.0;

// === KHOI TAO DOI TUONG ===
HX711_ADC LoadCellLeft(DOUT_PIN_LEFT, SCK_PIN_LEFT);
HX711_ADC LoadCellRight(DOUT_PIN_PHAI, SCK_PIN_PHAI);
AccelStepper stepper(AccelStepper::DRIVER, STEP_PIN, DIR_PIN);

unsigned long t_pid = 0;
unsigned long t_print = 0;
float fL = 0, fR = 0, targetSpeed = 0, currentSpeed = 0;
boolean isBalancing = false;

void setup() {
    Serial.begin(115200);
    pinMode(HOME_SWITCH_PIN, INPUT_PULLUP);

    // Khoi tao Loadcell
    LoadCellLeft.begin(); LoadCellRight.begin();
    LoadCellLeft.start(1000, true);
    LoadCellRight.start(1000, true);
    LoadCellLeft.setCalFactor(CALIB_LEFT);
    LoadCellRight.setCalFactor(CALIB_RIGHT);

    // Khoi tao PID
    myPID.SetMode(AUTOMATIC);
    myPID.SetOutputLimits(-MAX_SPEED_PID, MAX_SPEED_PID);
    myPID.SetSampleTime(20);

    // Khoi tao Dong co
    stepper.setMaxSpeed(MAX_SPEED_PID);
    stepper.setAcceleration(MOTOR_ACCEL);

    runHomingSequence();
}

void loop() {
    // Nhiem vu nen
    LoadCellLeft.update();
    LoadCellRight.update();
    stepper.runSpeed();

    // Nhiem vu dieu khien (20ms)
    if (millis() > t_pid + 20) {
        float rawL = LoadCellLeft.getData();
        float rawR = LoadCellRight.getData();
        fL = ceil(rawL / STEP_SIZE) * STEP_SIZE;
        fR = ceil(rawR / STEP_SIZE) * STEP_SIZE;
        Input = fR - fL;

        float startThreshold = ACCEPTABLE_RANGE + HYSTERESIS_GAP;
        float stopThreshold = ACCEPTABLE_RANGE - HYSTERESIS_GAP;

        if (!isBalancing && abs(Input) > startThreshold) {
            isBalancing = true;
            myPID.SetMode(AUTOMATIC);
        }
        else if (isBalancing && abs(Input) < stopThreshold) {
            isBalancing = false;
            Output = 0;
            myPID.SetMode(MANUAL);
        }

        if (isBalancing) {
            myPID.Compute();
            float rawSpeed = Output;
            if (abs(rawSpeed) > 0 && abs(rawSpeed) < MIN_SPEED_THRESHOLD) {
                targetSpeed = (rawSpeed > 0) ? MIN_SPEED_THRESHOLD : -MIN_SPEED_THRESHOLD;
            } else {
                targetSpeed = rawSpeed;
            }
        } else {
            targetSpeed = 0;
        }

        long currentPos = stepper.currentPosition();
        if (currentPos <= MAX_POS_LEFT && targetSpeed < 0) targetSpeed = 0;
        if (currentPos >= MAX_POS_RIGHT && targetSpeed > 0) targetSpeed = 0;

        stepper.setSpeed(targetSpeed);
        currentSpeed = targetSpeed;
        t_pid = millis();
    }

    // Nhiem vu giam sat (100ms)
    if (millis() > t_print + 100) {
        Serial.print("L: "); Serial.print(fL, 0);
        Serial.print(" | R: "); Serial.print(fR, 0);
        Serial.print(" | Lech: "); Serial.print(Input, 0);
        Serial.print(" | Spd: "); Serial.print(currentSpeed, 0);
        Serial.println(isBalancing ? " [RUN]" : " [OK]");
        t_print = millis();
    }
}

void runHomingSequence() {
    Serial.println("[HOMING] Bat dau ve Home...");
    stepper.setSpeed(HOMING_SPEED_FAST);
    while (digitalRead(HOME_SWITCH_PIN) == HIGH) { stepper.runSpeed(); }
    stepper.stop();
    stepper.setCurrentPosition(MAX_POS_RIGHT);

    stepper.moveTo(MAX_POS_RIGHT - (5.0 * STEPS_PER_MM));
    while (stepper.distanceToGo() != 0) { stepper.run(); }

    stepper.setSpeed(HOMING_SPEED_SLOW);
    while (digitalRead(HOME_SWITCH_PIN) == HIGH) { stepper.runSpeed(); }
    stepper.stop();
    stepper.setCurrentPosition(MAX_POS_RIGHT);

    stepper.moveTo(0);
    while (stepper.distanceToGo() != 0) { stepper.run(); }

    delay(5000); // Cho on dinh
    Serial.println("[HOMING] Hoan tat.");
}
\end{lstlisting}

\end{document}
